- HTML <script> Tag: The <script> tag is used to embed a client-side script (JavaScript). The <script> element either contains scripting statements, or it points to an external script file through the src attribute. Common uses for 
  JavaScript are image manipulation, form validation, and dynamic changes of content.

    ~ <script src="./main.js"></script>         
    ~ <script async src="./main.js"></script        Specifies that the script is downloaded in parallel to parsing the page, and executed as soon as it is available (before parsing completes) (only for external scripts)
    ~ <script defersrc="./main.js"></script>        Specifies that the script is downloaded in parallel to parsing the page, and executed after the page has finished parsing (only for external scripts)

Existen tres casos para poner el archivo script, los cuales son: 
  1) Cuando no tenemos ningun atributo en el script, lo que se hace primro es que el navegador interpretare el archivo HTML para que se descargue el script y despues de eso, seguir con la interpretacion del JS (va al final del HTML)
  2) El segundo caso reduce el tiempo de pausa de interpretacion del html, por lo que ganaermos en cargar mas cosas antes de llegar a la pausa (va al final del head)
  3) El ultimo, sirve para no bloquear la interpretacion del HTML en toda la descarga de la web. Esta se realiza igual que el segundo caso, pero con la diferencia de que la ejecucion se hace despues de la carga (va al final del head)


- Como crear variables en javascript

   > var definimos una variable con local scope, también nos permite utilizar un comportamiento llamado hoisting, sin generar ningún error. El ámbito, significa esencialmente dónde están disponibles estas variables para su uso. Las
     declaraciones var tienen un ámbito global o un ámbito de función/local. El ámbito es global cuando una variable var se declara fuera de una función. Esto significa que cualquier variable que se declare con var fuera de una función está 
     disponible para su uso en toda la pantalla. var tiene un ámbito local cuando se declara dentro de una función. Esto significa que está disponible y solo se puede acceder a ella dentro de esa función. 
     Las variables con var se pueden volver a declarar y modificar. 

   > let definimos variable con block scope, las variables declaradas de esta manera nos genera un error de referencia cuando intentamos utilizar hoisting. Un bloque es un trozo de código delimitado por {}. Un bloque vive entre llaves. Todo 
     lo que está dentro de llaves es un bloque. Así que una variable declarada en un bloque con let  solo está disponible para su uso dentro de ese bloque.

   > const definimos variables de sólo lectura (no confundir con inmutables), esto quiere decir que, cuando asignamos una variable, el nombre de esta va estar asignada a un puntero en memoria, el cual no puede ser sobreescrito o reasignado.
     Las variables declaradas con const mantienen valores constantes. Las declaraciones const similitudes con las declaraciones let. Al igual que las declaraciones let, solamente se puede acceder a las declaraciones const dentro del bloque 
     en el que fueron declaradas. const no puede modificarse ni volver a declararse Esto significa que el valor de una variable declarada con const s el mismo dentro de su ámbito. No se puede actualizar ni volver a declarar. 
     
     Las declaraciones con let y const tienen controles adicionales para las variables. Principalmente impiden que se puedan crear dos variables con el mismo nombre. Una variable let puede recibir múltiples asignaciones en el transcurso de 
     la aplicación, es decir que puede cambiar de valor varias veces. Una constante const recibe una única asignación al momento de su declaración, impidiendo que su valor se modifique luego.
     
     let te permite declarar variables limitando su alcance (scope) al bloque, declaración, o expresión donde se está usando. A diferencia de la palabra clave var la cual define una variable global o local en una función sin importar el 
     ámbito del bloque. La otra diferencia entre var y let es que este último se inicializa a un valor sólo cuando un analizador lo evalúa. Al igual que const, let no crea propiedades del objeto se declara globalmente (en el alcance más 
     alto)

- Tipos de mensajes en pantalla

    > prompt(): La sentencia prompt() mostrará un cuadro de diálogo para que el usuario ingrese un dato. Se puede proporcionar un mensaje que se colocará sobre el campo de texto. El valor que devuelve es una cadena que representa lo que el 
      usuario ingresó. En la pantalla del navegador, el usuario verá una ventana sobre la web que le solicitará un dato. Al valor que el usuario ingresa se lo conoce por el término de entrada.
                                                                          
    > console.log(): La sentencia console.log() muestra el mensaje que pasemos como parámetro a la llamada en la consola JavaScript del Navegador web
    
    > alert(): mostrará una ventana sobre la página web que estemos accediendo mostrando el mensaje que se pase como parámetro a la llamada. Al valor que mostramos al usuario como un resultado se lo conoce por el término de salida.
    
    > Existen dos formas de concatenar algo: 
      1. +;
      2. ` ${nombreDeVariable} `;

- Operadores logicos

==             Es igual                                       a == b
===            Es estrictamente igual                         a === b
!=             Es distinto                                    a != b
!==            Es estrictamente distinto                      a != b
<, <=, >, >=   Menor, menor o igual, mayor, mayor o igual     a <= b
&&             Operador and (y)                               a && b
||             Operador or (o)                                a || b
!              Operador not (no)                              !a

   > Diferencia entre "==" y "===": El operador de estricta igualdad ( === ) revisa si dos operandos son iguales y produce un resultado Booleano. A diferencia del operador de igualdad regular (==), el operador de estricta igualdad siempre
     considera que los operandos de distinto tipo de valor son diferentes y nunca similares.
     (==): Se utiliza para comparar variables o valores.	 Los dobles iguales no comprueban el tipo de dato variable/valor mientras se hace la comparación. Usa este operador cuando no estés seguro sobre el tipo de datos de la 
     variable/valor. ‘1’ == 1 Esto devolverá true porque los valores dobles iguales no verifican el tipo de datos. 0 == falseDevolverá true porque convierte el 0 en falso y luego lo compara. 7 == “7” // true	
     (===): También se utiliza para comparar variables/valores. Triple igual comprueba el tipo de datos de una variable durante la comparación. Usa este operador cuando estés seguro del tipo de datos de la variable/valor y desees una 
            comparación estricta. ‘1’ === 1Esto devolverá false porque los triples iguales también comparan el tipo de datos. Simplemente el 1 es de tipo string y no es un número. 0 === false Devolverá false porque son diferentes tipos de 
            datos. 7 === “7” // false
               
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Funciones

  > Declaracion de una funcion: una función, declarada como una instrucción separada, en el flujo de código principal.
       
       function sum(a, b) {
       return a + b;
       };
    
    Una Declaración de Función puede ser llamada antes de ser definida. Por ejemplo, una Declaración de Función global es visible en todo el script, sin importar dónde se esté. Esto se debe a los algoritmos internos. Cuando JavaScript se 
    prepara para ejecutar el script, primero busca Declaraciones de Funciones globales en él y crea las funciones. Podemos pensar en esto como una “etapa de inicialización”. Y después de que se procesen todas las Declaraciones de Funciones, 
    el código se ejecuta. Entonces tiene acceso a éstas funciones.
    Si la función se declara como una declaración separada en el flujo del código principal, eso se llama “Declaración de función”.
    Las Declaraciones de Funciones se procesan antes de ejecutar el bloque de código. Son visibles en todas partes del bloque.
      
  > Expresion de una funcion: una función, creada dentro de una expresión o dentro de otra construcción sintáctica. Aquí, la función es creada en el lado derecho de la “expresión de asignación” =:
    Tambien son conocidas como "funciones anónimas" que es una función que se define sin nombre y se utiliza para ser pasada como parámetro o asignada a una variable. En el caso de asignarla a una variable, pueden llamar usando el 
    identificador de la variable declarada.

      let sum = function(a, b) {
      return a + b;
      };
    
    Una Expresión de Función es creada cuando la ejecución la alcance y es utilizable desde ahí en adelante. Una vez que el flujo de ejecución pase al lado derecho de la asignación let sum = function… – aquí vamos, la función es creada y 
    puede ser usada (asignada, llamada, etc.) de ahora en adelante. Las Declaraciones de Función son diferente.
    Si la función se crea como parte de una expresión, se llama “Expresión de función”.
    Las Expresiones de Función se crean cuando el flujo de ejecución las alcanza.
      
  > Funciones flecha Son como funciones anónimas de sintaxis simplificada. No usan la palabra function pero usa => (flecha) entre los parámetros y el bloque. Las funciones flecha permiten definir de manera compacta una función convencional. 
    Si la función tiene solamente una sentencia que devuelve un valor, el uso de funciones flecha nos permite eliminar las llaves y la palabra return. Incluso utilizando parámetros también podemos ver mucho más reducido el código.
    No tiene sus propios enlaces a this o super y no se debe usar como métodos. No tiene argumentos o palabras clave new.target. No apta para los métodos call, apply y bind, que generalmente se basan en establecer un ámbito o alcance No se 
    puede utilizar como constructor. No se puede utilizar yield dentro de su cuerpo.
    
      + const calcAge3 = birthYear => 2037 - birthYear;               //Esta funcion flecha se escribe de esta manera cuando solamente requiere de una linea de codigo. Aqui no se necesita de un retur.
      + const yearUntilRetirement1 = (birthYear, firstName) => {}     //Esta funcion se utiliza con llaves cuando se requiere de mas de 1 linea. Se requiere de un return si es que queremos regresar un valor.
      + const yearUntilRetirement1 = function(birthYear, firstName){} //Esta funcion es la misma que la de arriba pero de la forma tradicional. Se requiere de un return si es que queremos regresar un valor.    
      + toString = () => {return this.nombre +" ($"+ this.precio.toFixed(2) +")"}; //Asi se define una funcion flecha dentro de una clase
      + toString(){return this.nombre +" ($"+ this.precio.toFixed(2) +")"} //Asi se define una funcion tradicional dentro de una clase
      
      
  > Anonymus function: 
  
  > Callback function: Lo primero que tenemos que saber es que en Javascript, las funciones son objetos de primera clase. Como tales, podemos trabajar con ellos de la misma forma que trabajamos con otros objetos, como asignarlos a variables 
    y pasarlos como argumentos a otras funciones. Esto es importante, porque esta última técnica nos permite ampliar la funcionalidad de nuestras aplicaciones.
    JavaScript ejecuta el código secuencialmente en orden descendente. Sin embargo, hay algunos casos en los que el código se ejecuta (o debe ejecutarse) después de que ocurra otra cosa y también de forma no secuencial. Esto se llama 
    programación asíncrona.
    Los callbacks aseguran que una función no se va a ejecutar antes de que se complete una tarea, sino que se ejecutará justo después de que la tarea se haya completado. Nos ayuda a desarrollar código JavaScript asíncrono y nos mantiene a 
    salvo de problemas y errores.
    En JavaScript, la forma de crear una función callback es pasándola como parámetro a otra función, y luego llamarla de vuelta justo después de que haya ocurrido algo o se haya completado alguna tarea.
        
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- POO en JAVASCRIPT

  > Objetos: os objetos son estructuras que podemos definir para agrupar valores bajo un mismo criterio. Podemos decir que un objeto es una colección de datos relacionados como una entidad. Se componen de un listado de pares clave-valor, es 
    decir, contienen propiedades y valores agrupados. La utilidad de los objetos deviene de su composición por varios valores y operaciones comunes (funciones) para todos los elementos de este tipo y sus propiedades". 
    + Anatomía de un objeto: Un objeto literal se define directamente entre llaves {} Los valores que almacenan se listan separados por coma, bajo la forma propiedad: valor
    + Obteniendo valores del objeto: Para obtener el valor de una propiedad en un objeto utilizamos la notación punto (.): El nombre de la variable del objeto, seguido de punto y el nombre de la propiedad.
      ~ Otra forma de obtener el valor de una propiedad en un objeto utilizamos la notación corchetes ([]): El nombre de la variable del objeto, seguido de corchetes y dentro de ellos un string del nombre de la propiedad.
    + Asignar valores a las propiedades: Es posible usar las dos formas( corchetes y paréntesis) para acceder a las propiedades y asignar nuevos valores a los datos almacenados en las propiedades del objeto
    
        
  > Formas de llamar a un objeto y diferencia entre Dot Notation y Bracket Notation Property Accessor:
        console.log(producto.nombre);
        console.log(producto['nombre']);     
        
    Cuando usamos corchetes podemos acceder a propiedades que tienen un espacio o carácter no permitido en la notación de punto (por ejemplo, miMascota.numero de amigos no es válido, pero miMascota["numero de amigos"] sí lo es). Si queremos 
    minificar nuestro código, la notación del punto no es válida, debemos usar la notación de corchetes. La notación con corchetes, a diferencia de la notación con punto, puede usarse con variables. Si usas una variable con notación con 
    corchetes, la variable debe hacer referencia a una string.
    Dot Notation only allows static keys while Bracket Notation accepts dynamic keys. Static key here means that the key is typed directly, while Dynamic key here means that the key is evaluated from an expression.
    
(1) const obj = {                                  (2) const obj = {                                    (3) const obj = {
    name: "deeecode",                                  name: "deeecode",                                    name: "deeecode",
    age: 80,                                           age: 80,                                             age: 80,
    language: "javascript",                            language: "javascript",                              language: "javascript",
    }                                                  }                                                    }
    
    const myKey = "language";                          const myKey = "language";                            const myKey = "language";
    const target = obj.myKey;                          const target = obj[myKey];                           const target = obj["myKey"];
    console.log(target);                               console.log(target);                                 console.log(target);
    //undefined                                        // javascript                                        // undefined
    
(4) const obj = {                                  (5) const obj = {                                        
    name: "deeecode",                                  name: "deeecode",                                    
    age: 80,                                           age: 80,                                             
    language: "javascript",                            language: "javascript",                              
    }                                                  }                   
                                     
    const target = obj.name;                           const target = obj["name"];                            
    console.log(target);                               console.log(target);                             
    //deecode                                          // javascript                                       
    
    
    
    1. Here, I assigned the value "language" to a myKey variable. What I would expect here is that when I use the dot notation, like obj.myKey, "myKey", should be replaced with "language". So it would read as obj.language and that would 
       return "javascript". But that's not what happens. Instead, the result is undefined. The reason for this is that Dot Notation only accepts static keys. So when you do obj.myKey, JavaScript looks for the property with the key myKey in 
       obj. But that property does not exist, so we get undefined. The Bracket Notation, on the other hand, allows dynamic keys. Because this notation accepts expressions, you can use any expression that evaluates to a value.
    2. The expression we passed to the square brackets is myKey which is a variable. This expression evaluates to "language" which is the value of the variable. Using this value, the square brackets can get the value of the property, which 
       is "javascript".
    3. This is because the string expression "myKey" evaluates to the value "myKey" which serves as the key for accessing the property. Since there's no myKey key on obj, the returned value is undefined.

  > Como crear un metodo en un objeto: En este caso se hace de la misma manera que cuando creamos una funcion global, con la diferencia de que en lugar de usar (=) usamos (:) solo cuando esta dentro del objeto
  
       calcAge: function (birthYeah){   //Metodo
           return variable;
       }
        
  > Llamar a la funcion de una clase: Para hacer esto, sabemos primero que la funcion se encuentra dentro de una clase, por lo que ahora, fuera de ella cuando queramos llamarla, tendremos que poner le nommbre de una variable, le colocamos un 
    punto y despues escribimos el nombre de la funcion. La sintaxis es la siguiente       -->       NombreDeVariable.nombreDeFuncion()

  > clases: Las clases de JavaScript, introducidas en ES6, proveen una sintaxis mucho más clara y simple para crear objetos personalizados. Son una equivalencia al empleo de función constructora y permite definir distintos tipos de métodos.
  
  > Clases y Métodos: En la declaración de clase, la función constructora es reemplazada por el método constructor. Los métodos en las clases no referencian a propiedades, se declaran dentro del bloque sin la palabra function. Los metodos se 
    declaran fuera del metodo constructor pero dentro de la clase. Estos metodos no llevan el "=" ni tampoco los "=>", a diferencia de la funcion constructora de objetos.

  > new: El operador new permite a los desarrolladores crear una instancia de un tipo de objeto definido por el usuario o de uno de los tipos de objeto integrados que tiene un función constructora.
    La palabra clave new hace lo siguiente:

      1) It creates a new object. The type of this object is simply object.
      2) It sets this new object's internal, inaccessible, [[prototype]] (i.e. __proto__) property to be the constructor function's external, accessible, prototype object (every function object automatically has a prototype property).
      3) It makes the this variable point to the newly created object.
      4) It executes the constructor function, using the newly created object whenever this is mentioned.
      5) It returns the newly created object, unless the constructor function returns a non-null object reference. In this case, that object reference is returned instead.    
      6) Para definir un tipo de objeto, crea una función para el tipo de objeto que especifique su nombre y propiedades. Un objeto puede tener una propiedad que en sí misma es otro objeto.
    
   Note: constructor function refers to the function after the new keyword, as in
        
        new ConstructorFunction(arg1, arg2)

   Once this is done, if an undefined property of the new object is requested, the script will check the object's [[prototype]] object for the property instead. This is how you can get something similar to traditional class inheritance in JS
   The most difficult part about this is point number 2. Every object (including functions) has this internal property called [[prototype]]. It can only be set at object creation time, either with new, with Object.create, or based on the 
   literal (functions default to Function.prototype, numbers to Number.prototype, etc.). It can only be read with Object.getPrototypeOf(someObject). There is no other way to get or set this value.
   Functions, in addition to the hidden [[prototype]] property, also have a property called prototype, and it is this that you can access, and modify, to provide inherited properties and methods for the objects you make. Here is an example:
   
   ObjMaker = function() { this.a = 'first'; };
   // `ObjMaker` is just a function, there's nothing special about it that makes it a constructor.
   
   ObjMaker.prototype.b = 'second';
   // like all functions, ObjMaker has an accessible `prototype` property that we can alter. I just added a property called 'b' to it. Like all objects, ObjMaker also has an inaccessible `[[prototype]]` property that we can't do anything
   
   with obj1 = new ObjMaker(); 
   //3 things just happened. A new, empty object was created called `obj1`.  At first `obj1` was just `{}`. The `[[prototype]]` property of `obj1` was then set to the currentobject value of the `ObjMaker.prototype` (if `ObjMaker.prototype` 
   is laterassigned a new object value, `obj1`'s `[[prototype]]` will not change, but youcan alter the properties of `ObjMaker.prototype` to add to both the`prototype` and `[[prototype]]`). The `ObjMaker` function was executed, with`obj1` in 
   place of `this`... so `obj1.a` was set to 'first'.
   
   obj1.a;
   // returns 'first'
   
   obj1.b; 
   //`obj1` doesn't have a property called 'b', so JavaScript checks  its `[[prototype]]`. Its `[[prototype]]` is the same as `ObjMaker.prototype` `ObjMaker.prototype` has a property called 'b' with value 'second' returns 'second'

  > this: Se refiere al elemento actual en el que se está escribiendo el código. Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado. This es muy útil para 
      asegurar que se emplean las propiedades del objeto actual. El puntero this es una variable predefinida para todas las funciones u operadores miembro de una clase. Este puntero contiene la dirección del objeto concreto de la clase al 
      que se está aplicando la función o el operador miembro. Se puede decir que *this es un alias del objeto correspondiente. Conviene tener en cuenta que cuando una función miembro se aplica a un objeto de su clase (su argumento 
      implícito), accede directamente a las variables miembro (sin utilizar el operador punto o flecha), pero no tiene forma de referirse al objeto como tal, pues no le ha sido pasado explícitamente como argumento. Ojo, que hace referencia 
      al objeto instanciado y no a la clase.
      
      this en JavaScript es una palabra clave muy utilizada dentro de funciones y clases, pues tiene un valor flexible. This hace referencia al objeto en cuestión. Es decir, si estamos creando cualquier función, la palabra clave this se 
      usará para representar o llamar al objeto que dicha función está modificando. ES5 introdujo el método bind() para establecer el valor de la función this independientemente de como es llamada.
      this es una referencia que se crea cuando una función es invocada, no declarada. El valor de esa referencia depende al 100% del lugar en la que esa invocación se realice, llamado call-site. Ese lugar de llamada es la invocación en sí a 
      la función. Es decir, el momento justo en que es llamada (no declarada, no referenciada) esa función. El valor de this puede cambiar dependiendo del contexto en el que se invoca una función o método. Hay cuatro contextos principales en 
      los que se puede utilizar this en JavaScript:
        + En una función global: En una función que se ejecuta en el contexto global, this hace referencia al objeto window, que es el objeto global en JavaScript.
      
        + En una función dentro de un objeto: Cuando se invoca una función dentro de un objeto, this hace referencia al objeto que contiene la función.
       
        + El método call() o apply(): Son métodos que permiten invocar una función con un objeto diferente de this. Esto significa que se puede cambiar el contexto de this mediante la llamada a una de estas do funciones.
          ~ call ();  Permite que una función/método que pertenece a un objeto, ser asignada y llamada para un objeto diferente. Provee un nuevo valor de this a la función/método. Podemos escribir un método ona vez y heredarlo a otro objeto, 
                      sin tener que reescribir el método en el nuevo objeto. No recive una lista de argumentos despues del this.
                      You can write a method that can be used on different objects. It takes arguments separately. It can be used to invoke (call) a method with an owner object as an argument (parameter). With call(), an object can use a 
                      method belonging to another object. 
          ~ apply (); Con apply , puede escribirse un método una vez y heredarlo a otro objeto, sin necesidad de reescribir el método para adecuarlo al nuevo objeto. apply es muy similar a call() , excepto por el tipo de argumentos que 
                      soporta. Puede utilizarse un arreglo de parámetros en lugar de un conjunto de pares nombre-valor. You can write a method that can be used on different objects. It takes arguments as an array.
          ~ bind (); El método bind() crea una nueva función, que cuando es llamada, asigna a su operador this el valor entregado, con una secuencia de argumentos dados precediendo a cualquiera entregados cuando la función es llamada. El 
                     valor de this es ignorado cuando la función es llamada con el operador new.
                     Allows us to manually set "this" for any function call. With the bind() method, an object can borrow a method from another object. Bind doesn't immediately call the function. Instead, it returns a new function where the 
                     "this" is bound. So it's set to whatever value we pass into bind. Sometimes the bind() method has to be used to prevent losing this.
        
        + Con el operador new: Cuando se invoca una función con el operador new, this hace referencia al objeto que se está creando.
        
      In JavaScript, the this keyword refers to an object. Which object depends on how this is being invoked (used or called). The this keyword refers to different objects depending on how it is used:
         ~ In an object method, this refers to the object.
         ~ Alone, this refers to the global object.
         ~ In a function, this refers to the global object.
         ~ In a function, in strict mode, this is undefined.
         ~ In an event, this refers to the element that received the event.
         ~ Methods like call(), apply(), and bind() can refer this to any object.  
      
      En resumen, this se utiliza para hacer referencia al objeto en el contexto actual, y su valor puede cambiar dependiendo del contexto en el que se invoca una función o método. Conocer cómo funciona this en diferentes contextos es 
      esencial para escribir código efectivo en JavaScript.       https://www.freecodecamp.org/espanol/news/la-guia-completa-sobre-this-en-javascript/   https://www.programiz.com/javascript/this

  > super: The super keyword is used to call the constructor of its parent class to access the parent's properties and methods, to access properties on an object literal or class's [[Prototype]], or invoke a superclass's constructor.

  > extends: The extends keyword is used to create a child class of another class (parent). The child class inherits all the methods from another class. Inheritance is useful for code reusability: reuse properties and methods of an existing 
    class when you create a new class. 
    Note: From the example above; The super() method refers to the parent class. By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.
    Extends is used to denote the parent class that the child class will inherit its methods from, and super is used to reference the parent classes constructor method.
      
  > Constructor: El constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con función constructora podemos inicializar las propiedades del objeto al momento de ser instanciado con new.
    A constructor is a special function that creates and initializes an object instance of a class. In JavaScript, a constructor gets called when an object is created using the new keyword. 
    The purpose of a constructor is to create a new object and set values for any existing object properties.
      
        function Persona(nombre, edad, calle) {
           this.nombre = nombre;
           this.edad = edad;
           this.calle = calle;
        }
        const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742 ");
        const persona2 = new Persona("Marge", 36, "Av. Siempreviva 742 ");
        
     Estos metodos constructores NO son asincronos.

  
  > Metodo: Los métodos de los objetos también son técnicamente funciones, sólo que se limitan a poder ser ejecutados solo desde el mismo objeto. Se requiere un objeto y puede no retornar un valor.
        function Persona(nombre, edad, calle) {
           this.nombre = nombre; this.edad = edad; this.calle = calle;
        } 
        
  > Encaptulation: It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In Encapsulation, the variables or data of a class are hidden from any 
    other class and can be accessed only through any member function of their class in which they are declared. As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.    
    
    This principle states that all important information is contained inside an object and only select information is exposed. The implementation and state of each object are privately held inside a defined class. Other objects do not have 
    access to this class or the authority to make changes. They are only able to call a list of public functions or methods. This characteristic of data hiding provides greater program security and avoids unintended data corruption.
    
     ~ Public: These members of the class and available to everyone that can access the (owner) class instance.
     
     ~ Private: These members are only accessible within the class that instantiated the object.
     
     ~ Protected: This keyword allows a little more access than private members but a lot less than the public. A protected member is accessible within the class (similar to private) and any object that inherits from it. A protected value is 
       shared across all layers of the prototype chain. It is not accessible by anybody else.
        
  > Diferencia entre una funcion constructora de objetos y las clases, y la forma en que se escriben:
  
  function producto(nombre, precio, cantidad){   //Funcion constructora de objetos
    //propiedades
    this.nombre = nombre;
    this.precio = parseFloat(precio);
    this.cantidad = parseInt(cantidad);
    this.hayInventario = !!parseInt(cantidad);
        
    //Metodos y funciones
    this.toString = function() {return this.nombre;};
    this.Stock   = (cantidadIncrementada) => {this.cantidad += this.cantidad + parseInt(cantidadIncrementada);};
    this.comprar = (cantidadComprada) => {this.cantidad -= parseInt(cantidadComprada);};
    }; 
        
    
    class producto{
       //Metodo constructor de una clase
       constructor(nombre, precio, cantidad){
           this.nombre = nombre;
           this.precio = parseFloat(precio);
           this.cantidad = parseInt(cantidad);
           this.hayInventario = !!parseInt(cantidad);
       };

    //Metodos y funciones
    toString() {return this.nombre;}
    incrementarStock(cantidadIncrementada) {this.cantidad = this.cantidad + parseInt(cantidadIncrementada);}
    comprar(cantidadComprada) {this.cantidad = this.cantidad - parseInt(cantidadComprada);}
    }  
    
  > Array de objetos: Los array pueden usarse para almacenar objetos personalizados. Podemos asignar objetos literales o previamente instanciados en la declaración del array o agregar nuevos objetos usando el método push y el constructor.
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Conceptos y definiciones de POO
    
  > Objeto: los objetos tienen propiedas especificas, tales como posicion, tamano, color, etc., que definen su estado. Los objetos tambien tienen ciertos comportamientos que los hacen diferentes 
    de otros objetos. Cada objeto forsozamente debe tener tanto atributos como metodos, y se debe crear siempre despues de las clases. Los objetos poseen: 
    + Atributos (Caracteristica, datos o miembros de la clase): Son las descripciones que posee dicho objeto. Es decir, su informacion. Tambien, es una característica de un objeto, que ayuda a definir su estructura y permite diferenciarlo de
      otros objetos. Se define con un identificador y un tipo, el cual indica los valores que puede almacenar. El conjunto de valores de los campos  definen el estado del objeto. En codigo, son unicamente los nombres de algo, como por 
      ejemplo, el color, altura, velocidad, peso o precio, y son de tipo int, string, float, etc.
    + Metodos (acciones, funcionalidades o parametros): Son las acciones o tareas que estas pueden desempenar, como lo son sumar(), encender(), abrir() etc. Se debe crear en un archivo deferente al que se uso para crear una clase. Tambien, 
      son los comportamientos o conductas de un objeto y permite identificar la forma en que actúa respecto a su entorno o respecto a otros objetos. Además, representa una operación o función que un objeto realiza. El conjunto de los métodos 
      de un objeto determinan el comportamiento general del objeto. En codigo, los metodos son las funciones que ejecutaran una accion, por ejemplo: los metodos seters, geters, fucniones void, o aquellas que retornan un valor

  > Clase: Es un conjunto de objetos que comparten una estructura y comporamiento comunes. Una clase se debe crear antes que los objetos. Y debe tener el metodo constructor. Se debe crear en un archivo deferente al que se uso para crear una 
    metodo. Se puede crear una clase usando la palabra clave struct, la diferencia es que con struct los miembros se hacen públicos por defecto, mientras que con class se hacen privados por defecto. 
    + De instancia: Son aquellas que se declaran dentro de una clase y que no existen hasta que se hace una instancia de esa clase (se crea un objeto) nombre [ = ];
    + De referencia: Son aquellas que hace referencia a otra clase. Esto se puede definir mejor diciendo que es una variable del tipo de otra clase, y cuando se haga la instancia tendremos: un objeto dentro de otro objeto. nombre [ = ];
    + De clase: Estas variables se declaran antemoniendo la palabra static a su declaración, y a diferencia de las variables de instancia, éstas no necesitan que se haga una instancia (que se cree un objeto), existen desde que se crea la 
      clase.static nombre [ = ];
      
    + clases abstractas: A veces es posible que nos interese que una clase sea abstracta. Con esto lo que queremos decir es que a veces no tiene finalidad alguna crear un objeto de una clase que no tenga funcionalidad pero represente un 
     concepto de clase útil. Se utilizan solo como clase base, y a traves de ella van a derivar 1 o varias clases para tener clases hijas. NO SE PUEDEN ISNTANCIAR (CREAR) OBJETOS EN ESA CLASE, sino que solamente serviran para crear clases 
     derivadas. Sirven para proporcionar una clase base apropiada a partir de la cual heredan otras clases. Es decir, se le pueden sacar clase derivadas y no se pueden crear objetos.     
    + Clases derivadas: Es la relacion que existe entre dos clases, en la que una clase denominada hija o clase derivada se crea a partir de otra ya existente, denominada clase padre o clase base. Para crear una clase derivada, tras el 
      nombre de la clase, se pondrán dos puntos y el nombre de la clase que se quiere tomar como base. Además, deberemos especificar el tipo de herencia, lo cual se especificará delante del nombre de la clase base. Las clases derivadas 
      pueden acceder a todo lo de la clase principal.
    + Clase padre: La clase de la cual otra deriva directamente. Decimos que la clase A es padre de la clase B si B deriva directamente de A (está conectada directamente en el árbol de jerarquías de las clases).
    + Clase hija: Clase que es derivada directamente de otra. Decimos que la clase B es hija de la clase A si B deriva directamente de A (está conectada directamente en el árbol de jerarquías de las clases).
    + Clase base: Llamamos así a la clase que se halla al inicio del árbol de las jerarquías de clases. La raíz de ese árbol es la clase base o superclase.
    + Clases compuestas: Es aquella clase que entre sus atributos tiene objetos que derivan de otras clases. Es decir, no tienen ningun parentezco ninguna ni otra.
    + Clase contenedora: Al hecho de crear nuevas clases utilizando otras clases como componentes, se le llama composición, y a la clase compuesta se le llama contenedora. Es decir, si alguno de los datos de una clase es a su vez una 
      instancia de otra clase (o de sí misma) a la clase se le llama contenedoras y a las clases albergadas contenidas.
      
  > Encapsulación (visualizacion de los miembros de la clase): Este concepto permite tener un control de acceso selectivo tanto a los miembros como a los métodos, de tal forma que desde fuera del objeto sólo se pueda acceder a los métodos e 
    identificadores que permita el creador del objeto.
    
    This principle states that all important information is contained inside an object and only select information is exposed. The implementation and state of each object are privately held inside a defined class. Other objects do not have 
    access to this class or the authority to make changes. They are only able to call a list of public functions or methods. This characteristic of data hiding provides greater program security and avoids unintended data corruption.

  
  > Abstracción: Son las características especificas de un objeto, aquellas que lo distinguen de los demás tipos de objetos y que logran definir límites conceptuales respecto a quien está haciendo dicha abstracción del objeto. Una 
    abstracción se enfoca en la visión externa de un objeto, separa el comportamiento específico de un objeto, a esta división que realiza se le conoce como la barrera de abstracción, la cuál se consigue aplicando el principio de mínimo 
    compromiso. La abstracción es el proceso por el cual se descarta toda aquella información que no resulta relevante en un contexto en particular enfatizando algunos de los detalles o propiedades de los objetos. Depende principalmente del 
    interés del observador, permitiendo abstracciones muy diferentes de la misma realidad, debido a esto algunos la clasifican un tanto subjetiva. Y consiste en captar las características y funcionalidades que un objeto desempeña y estos son
    representados en clases por medio de atributos y métodos de dicha clase.
    
      + principio de mínimo compromiso: Se refiere al proceso por el cuál la interfaz de un objeto muestra su comportamientoespecífico y nada más, absolutamente nada más.
      + Interfaz: Una interfaz de objeto permite crear código con el cuál se específica que métodos serán implementados por una clase sin necesidad de definir que harán estos métodos, dichos métodos deben ser públicos.
      + Abstracción de Entidades: Es un objeto que representa un modelo útil de una entidad que se desea.
      + Abstracción de Acciones: Un objeto que representa un conjunto de operaciones y todas ellas desempeñan funciones del mismo tipo.
      + Abstracción de Máquinas virtuales: Un objeto que agrupa operaciones, todas ellas virtuales, utilizadas por algún nivel superior de control u operaciones.
      + Abstracción de coincidencia: Un objeto que almacena un conjunto de operaciones que no tienen relación entre sí.
          
    Abstraction is a process which displays only the information needed and hides the unnecessary information. We can say that the main purpose of abstraction is data hiding. Abstraction means selecting data from a large number of data to 
    show the information needed, which helps in reducing programming complexity and efforts.  
    There are also abstract classes and abstract methods. An abstract class is a type of class that declares one or more abstract methods. An abstract method is a method that has a method definition but not implementation. Once we have 
    modelled our object using data abstraction, the same sets of data can also be used in different applications—abstract classes, generic types of behaviours and object-oriented programming hierarchy. Abstract methods are used when two or 
    more subclasses do the same task in different ways and through different implementations. An abstract class can have both methods, i.e., abstract methods and regular methods.

  
  > Herencia: Permite la reutilización y la extensión del código. Permite diseñar nuevas clases a partir de otras ya existentes, pudiéndose además extender sus métodos (cambiar su semántica en la  clase que hereda). Aqui, una clase base o 
    hija, se crea a partir de otra ya existente, las llamadas clase padre o base. La herencia define relaciones jerárquicas entre clases, de forma que atributos y métodos comunes puedan ser reutilizados. Las clases principales extienden 
    atributos y comportamientos a las clases secundarias. A través de la definición en una clase de los atributos y comportamientos básicos, se pueden crear clases secundarias, ampliando así la funcionalidad de la clase principal y 
    agregando atributos y comportamientos adicionales.La herencia es una de las características fundamentales de la Programación Orientada a Objetos por la que, tomando como base una clase ya existente, es posible derivar una nueva, que 
    heredará todos sus miembros, teniendo posibilidad de sobrecargarlos, crear unos nuevos o utilizarlos. La idea básica por tanto, es reutilizar las clases existentes y extender o modificar su semántica.
    
      + Herencia publica: En general, significa que una clase derivada tiene acceso a los elementos protegidos y publicos de su clase base. Los elementos publicos se heredan como elementos publicos; los elementos protegidos permanecen 
        protegidos; los elementos privados no se heredan.
      + Herencia privada: Los miembros publicos y protegidos de la clase base se vuelven miembros privados de la clase derivada. En efecto, los usuarios de la clase derivada no tiene acceso a las facilidades proportcionadas por la clase 
        base. Los miembros privados de la clase base son inaccesibles a las funciones miembro de la clase derivada. 
      + Herencia protegida: Todos los miembros públicos de la clase base adquieren el nivel de acceso protegido en las clases derivadas, mientras que los miembros 
        protegidos conservan su nivel de acceso. Lo anterior indica que una clase derivada puede luego heredar a otra clase los miembros protegidos que heredó de su clase base.
      + Herencia multiple: Es un tipo de herencia en la que una clase hereda los miembros de mas de una clase base. Es decir, existen multiples clases base (padres) para la clase derivada (hija). Esta herencia plantea diferentes problemas 
        tales como la ambiguedad por el uso de nombres identicos en diferentes clases base. Los problemas que se pueden presentar cuando se danan clases con herencia multiple son:
        ~ colisiones de nombres: de diferentes clases base (dos o mas clases base tiene el mismo identificador para algun elemento de su interfaz. Se resuelve con el operador de ambito ::)
        ~ Herencia repetida de una misma clase base (una clase puede heredar indirectamente dos copias de una clase base. Se resuelve con el operador de resolucion de ambito ::)
        
     
     Inheritance is a method in which one object acquires/inherits another object’s properties, and inheritance also supports hierarchical classification. The idea behind this is that we can create new classes built on existing classes, 
     i.e., when you inherit from an existing class, we can reuse methods and fields of the parent class. Inheritance represents the parent-child relationship. For example, a whale is a part of the classification of marine animals, which is 
     part of class mammal, which is under that class of animal. We use hierarchical classification, i.e., top-down classification. If we want to describe a more specific class of animals such as mammals, they would have more specific 
     attributes such as teeth; cold-blooded, warm-blooded, etc. This comes under the subclass of animals whereas animals come under the superclass. The subclass is a class which inherits properties of the superclass. This is also called a 
     derived class. A superclass is a base class or parental class from which a subclass inherits properties.
  
  > Polimorfismo: Es la posibilidad de definir clases diferentes que tienen métodos o atributos denominados de forma idéntica, pero que se comportan de manera distinta al mismo mensaje. Esto hace referencia al hecho de que varios objetos de 
    diferentes clases, pero con una base común, se pueden usar de manera indistinta, sin tener que saber de qué clase exacta son para poder hacerlo. 
    
    *El concepto de polimorfismo se puede aplicar tanto a funciones como a tipos de datos. Así nacen los conceptos de funciones polimórficas y tipos polimórficos. Las primeras son aquellas funciones que pueden evaluarse o ser aplicadas a 
     diferentes tipos de datos de forma indistinta; los tipos polimórficos, por su parte, son aquellos tipos de datos que contienen al menos un elemento cuyo tipo no está especificado. Permite tratar de forma genérica objetos de distintas 
    clases, ahorrando así código y proporcionando simplicidad. Por tanto, trata de forma genérica objetos de distintos tipos derivados de una misma clase  de objetos.    
     
    *Es la capacidad que tienen ciertos lenguajes para hacer que, al enviar el mismo mensaje (o, en otras palabras, invocar al mismo método) desde distintos objetos, cada uno de esos objetos pueda 
     responder a ese mensaje (o a esa invocación) de forma distinta.     
    
    *Tambien es la capacidad que tienen los objetos de comportarse de múltiples formas sin olvidar que para esto se  requiere de la herencia, en si consiste en hacer referencia a objetos de una clase que puedan tomar comportamientos de 
     objetos descendientes de esta. Con el polimorfismo usamos la generalización olvidando los detalles concretos de los objetos para centrarnos en un punto en común mediante una clase padre.    
    
    *El concepto de polimorfismo se puede aplicar tanto a funciones como a tipos de datos. Así nacen los conceptos de funciones polimórficas y tipos polimórficos. Las primeras son aquellas funciones que pueden evaluarse o ser aplicadas a 
     diferentes tipos de datos de forma indistinta; los tipos polimórficos, por su parte, son aquellos tipos de datos que contienen al menos un elemento cuyo tipo no está especificado.
    
    *En lenguajes basados en clases y con un sistema de tipos de datos fuerte (independientemente de si la verificación se realiza en tiempo de compilación o de ejecución), es posible que el único modo de poder utilizar objetos de manera 
     polimórfica sea que compartan una raíz común, es decir, una jerarquía de clases, ya que esto proporciona la compatibilidad de tipos de datos necesaria para que sea posible utilizar una misma variable de referencia (que podrá apuntar a 
     objetos de diversas subclases de dicha jerarquía) para enviar el mismo mensaje (o un grupo de mensajes) al grupo de objetos que se tratan de manera polimórfica.
    
    El polimorfismo adquiere su maxima potencia cuando se utiliza en union de herencia. Para poder utilizar polimorfismo en C++ se debe tomar en cuenta lo siguiente:
     + Crear una jerarquia de clases con las operaciones importantes definidas por las funciones miembro declaradas como virtuales en la clase base
     + Las implementaciones especificas de las funciones virtuales se deben hacer en las clases derivadas. Cada clase derivada puede tener su propia version de las funciones.
     
    Polymorphism refers to many forms, or it is a process that performs a single action in different ways. It occurs when we have many classes related to each other by inheritance. Polymorphism is of two different types, i.e., compile-time 
    polymorphism and runtime polymorphism. One of the examples of Compile time polymorphism is that when we overload a static method in java. Run time polymorphism also called a dynamic method dispatch is a method in which a call to an 
    overridden method is resolved at run time rather than compile time. In this method, the overridden method is always called through the reference variable. By using method overloading and method overriding, we can perform polymorphism. 
    Generally, the concept of polymorphism is often expressed as one interface, and multiple methods. This reduces complexity by allowing the same interface to be used as a general class of action. 
     
  > this: Se refiere al elemento actual en el que se está escribiendo el código. Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado. This es muy útil para 
    asegurar que se emplean las propiedades del objeto actual. El puntero this es una variable predefinida para todas las funciones u operadores miembro de una clase. Este puntero contiene la dirección del objeto concreto de la clase al 
    que se está aplicando la función o el operador miembro. Se puede decir que *this es un alias del objeto correspondiente. Conviene tener en cuenta que cuando una función miembro se aplica a un objeto de su clase (su argumento 
    implícito), accede directamente a las variables miembro (sin utilizar el operador punto o flecha), pero no tiene forma de referirse al objeto como tal, pues no le ha sido pasado explícitamente como argumento. Ojo, que hace referencia 
    al objeto instanciado y no a la clase.
    
    This hace referencia al objeto actual de la clase, es decir, a una instancia concreta de la clase y nos sirve para usar los métodos y atributos de esa clase desde alguno de sus métodos, para llamar a otro de sus constructores o 
    simplemente para pasarle el objeto completo a algún otro método u objeto.
      
         
  > instanciacion: La instanciacion no es mas que la creacion de un objeto a partir de una clase o a la derivacion de un objeto con otro, la cual se crea desde un inicio. Un objeto creado de una clase tambien de denomina instancia de una
    clase. De esta forma, todos los objetos son instancias de algún otro, menos la clase Object que es la madre de todas. Cuando usted declara una clase, no se reserva memoria para la clase hasta que usted crea un objeto de la clase.
    Por ejemplo, si creamos una clase para un objeto que es para un carro, el cual tenga "velocidad", "potencia" y "color", entonces a partir de eso, podemos definir nuestro primer objeto, digamos "Carro_1", el cual posee las 3 
    caracteristicas mencionadas arriba. Ahora, si queremos instanciar, entonces debemos crear otro objeto, digamos "Carro_2", debera tener exactamente los mismas 3 caracteristicas definidas en un principio. Esto es la instanciacion.
  
  > Diferencia entre crear objetos e instanciar objetos: De una clase abstracta no se pueden instanciar objetos pero si crear. A continuacion un ejemplo de la sintaxis de cada uno:
   + NombreDeVariable *NombreDeVariable[2]; - Creamos un objeto
   + NombreDeVariable[0] = new OtraVariable(7,4); - instanciamos 2 objeto a partir del arreglo de objetos creado. Dicha instanciacion se crea a partir de la clase derivada, no de la clase base.
     Instancia significa simplemente crear una referencia(copia) o a la derivacion de un objeto con otro, mientras que crear un objeto (o instanciar una clase) significa cuando le damos vida a una clase que acabamos de crear utilizando la 
     palabra reservada "new", y que la ubicación de la memoria está asociada con el objeto (es una entidad en tiempo de ejecución de la clase) mediante el uso del nuevo operador. En palabras simples, Instancia se refiere a la copia del 
     objeto en un momento particular, mientras que objeto se refiere a la dirección de memoria de la clase.

  > CONSTRUCTOR: El constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con función constructora podemos inicializar las propiedades del objeto al momento de ser instanciado con new.
     Es un método que se ejecuta automáticamente cuando se define o se crea un objeto, y su función es inicializar el objeto y prepararlo para realizar las operaciones necesarias. Debe tener el mismo nombre de la clase y servira 
     para inicializar los atributos que la misma clase tenga. Las funciones constructoras son una técnica para crear objetos personalizados con valores predeterminados y métodos específicos. Al contrario de la notación de objetos literales,
     las funciones constructoras deben ser llamadas con la palabra clave "new" para asegurar que se está creando un nuevo objeto. Con las funciones constructoras podemos crear varios objetos a partir de una sola función y cada uno podrá 
     tener valores diferentes, algo que no es posible con los objetos literales. Además, las funciones constructoras nos permiten crear métodos específicos para los objetos creados a partir de ellas, lo que nos permite tener un mejor control 
     sobre el comportamiento de los objetos.

  > Miembros static de una clase: Miembros estaticos (static): Un dato declarado estático en una clase es un dato de una sola instancia, se crea al definir la clase y sólo existirá uno, independientemente del número de objetos que se creen. 
    Esto es bueno cuando todos los objetos van a compartir una misma variable. Los atributos de tipo "static" NO SE PUEDEN INICIALIZAR DENTRO DE LA CLASE, SINO FUERA DE ELLA. Los atributos pertenecen a la clase y no a los objetos, similar a 
    las  variables locales y globales. Es decir, se crea un atributo estatico y todos los objetos tendran el mismo valor para el mismo atributo. En el caso de los metodos de tipo "static" sucede exactamente lo mismo. Los miembros YA NO le
    pertenecen a los objetos instanciados, sino a la clase. Los métodos estáticos son llamados sin instanciar su clase. Son habitualmente utilizados para crear funciones para una aplicación.
    Permite el acceso a métodos y variables de clase sin la necesidad de instanciar un objeto de dicha clase, permitiendo la inicialización de forma cómoda y durante la carga de clase.
    
    El hecho de no poder disponer de "this" dentro de un método estático es debido a que el método no se invoca con relación a ningún objeto. Como has visto, usamos el nombre de la clase para invocarlo y no un objeto instanciado. Como sabes, 
    "this" tiene una referencia al objeto donde se lanzó un mensaje (el objeto sobre el que se invocó un método). Como no existe tal objeto de invocación, no existe un objeto en "this". En principio podríamos pensar que "this" entonces 
    valdrá "undefined", pero lo que hay en realidad es el código de la propia clase.
    
    The static keyword defines a static method or field for a class, or a static initialization block. Static properties cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself.
    Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.


  > Modificadores de acceso
    + Publico (public: ) = Un miembro público es accesible en cualquier lugar en el que exista un objeto de la clase. El modificador public ofrece la máxima visibilidad, una variable, método o clase con modificador public será visible desde 
      cualquier clase, aunque estén en paquetes distintos 
    + Protegidos (protected:) = Un miembro protegido sólo es accesible desde las clases que se hereden de la clase que lo contiene. Es visible para las clases que se encuentren en el mismo paquete y para cualquier subclase de esta aunque 
      este en otro paquete. Este modificador es utilizado normalmente para Herencias, así que lo estudiaremos más a fondo cuando lleguemos a las Herencias.
    + Privados (private: ) = Es miembro privado sólo es accesible por los métodos de la clase a la que pertenece. Cuando un método o atributo (variable) es declarada como private, su uso         
      queda restringido al interior de la misma clase, no siendo visible para el resto. Una clase no puede ser Private, sólo atributos y métodos.

     Puede ser accedido desde:	                     public       protected       default      private 
     Su misma clase                                   SI	          SI	         SI            SI
     Cualquier clase que esté en el mismo paquete     SI	          SI             SI            NO
     Cualquier subclase que esté en otro paquete      SI             SI	         NO            NO
     Cualquier otra clase que esté en otro paquete    SI	          NO             NO            NO

   > DESTRUCTOR: [ ~NombreDeVariable(); ] es un método que se ejecuta automáticamente cuando un objeto queda fuera del ámbito en el que se creó, y su función es destruir el objeto, liberando cualquier asignación dinámica de memoria que se 
     haga. Sirve para liberar memoria utilizada al crear los objetos cuando el programa finaliza. Esto cuando nosotros creamos nuestras clases e instanciamos muchos objetos de esas mismas clases y se utiliza mucha memoria en la computadora. 
     El no utilizar el constructor por defecto, puede no afectar nuestro programa, pero cuando manejamos con programas muy largos, es de suma recomendacion utilizarlos. Es un método de una clase cuyo fin es eliminar un objeto de una clase.
     El objeto puede tener o no definidos explícitamente el constructor y el destructor, o tener varios constructores.
     
   > Constructor por defecto: Es aquel en el cual no existe ningun tipo de paramateros y no contiene nada dentro. Tambien inicia todos los atributos con ceros binarios (o bien, no se inicializan). SE UTILIZA PARA LA CREACION DE OBJETOS 
     DINAMICOS. Cuando trabajamos con este tipo de objetos dinamicos, es correcto el usar o no ningun constructor, puesto que, no inicializamos los atributos directamente cuando se crea el arreglo en la funcion principal.
     
   > Destructor por defecto: Al igual que existe un constructor por defecto, existe un destructor por defecto. Este método, elimina de memoria el objeto al terminarse el ámbito de la variable que lo contiene, recuperando para su uso la 
     porción de memoria que el objeto ocupaba.
     
     
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
     
- JavaScript Object Reference
    > constructor	Returns the function that created an object's prototype
    > keys()	     Returns an Array Iterator object with the keys of an object
    > prototype	     Let you to add properties and methods to JavaScript objects
    > toString()	     Converts an object to a string and returns the result
    > valueOf()	     Returns the primitive value of an object
 
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Global Methods and Properties
    > decodeURI()	        Decodes a URI
    > decodeURIComponent()    Decodes a URI component
    > encodeURI()	        Encodes a URI
    > encodeURIComponent()	   Encodes a URI component
    > eval()	              Evaluates a string and executes it as if it was script code
    > Infinity	              A numeric value that represents positive/negative infinity
    > isFinite()	              Determines whether a value is a finite, legal number
    > isNaN()	              Determines whether a value is an illegal number
    > NaN	                  "Not-a-Number" value
    > Number()	             Converts an object or string' value to a number
    > parseFloat()	        Parses a string and returns a floating point number
    > parseInt()	             Parses a string and returns an integer
    > String()	             Converts an object's value to a string
    > undefined	             Indicates that a variable has not been assigned a value
    
    > constructor	   Returns the function that created an object's prototype
    > keys()	        Returns an Array Iterator object with the keys of an object
    > prototype	        Let you to add properties and methods to JavaScript objects
    > toString()         Converts an object to a string and returns the result
    > valueOf()	         Returns the primitive value of an object
    > values()           Object.values() returns an array whose elements are values of enumerable string-keyed properties found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates 
                         properties in the prototype chain as well. The order of the array returned by Object.values() is the same as that provided by a for...in loop.
                         
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Métodos del objeto CONSOLE

    > assert()	            Writes an error message to the console if a assertion is false
    > clear()	            Clears the console
    > count()	            Logs the number of times that this particular call to count() has been called
    > error()	            Outputs an error message to the console
    > group()	            Creates a new inline group in the console. This indents following console messages by an additional level, until console.groupEnd() is called
    > groupCollapsed()	 Creates a new inline group in the console. However, the new group is created collapsed. The user will need to use the disclosure button to expand it
    > groupEnd()	            Exits the current inline group in the console
    > info()	            Outputs an informational message to the console
    > log()	            Outputs a message to the console
    > table()	            Displays tabular data as a table
    > time()	            Starts a timer (can track how long an operation takes)
    > timeEnd()	            Stops a timer that was previously started by console.time()
    > trace()	            Outputs a stack trace to the console
    > warn()	            Outputs a warning message to the console
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- JavaScript Statement Identifiers

    > break	                    Exits a switch or a loop
    > class	                    Declares a class
    > const	                    Declares a variable with a constant value
    > continue	                    Breaks one iteration (in the loop) if a specified condition occurs, and continues with the next iteration in the loop
    > debugger	                    Stops the execution of JavaScript, and calls (if available) the debugging function
    > do while	              Executes a block of statements and repeats the block while a condition is true
    > for	                         Loops through a block of code a number of times
    > for in	                    Loops through the properties of an object
    > for of	                    Loops through the values of an iterable object
    > function	                    Declares a function
    > if else - else if	    Marks a block of statements to be executed depending on a condition
    > let	                          Declares a variable
    > return	                    Stops the execution of a function and returns a value from that function
    > switch	                    Marks a block of statements to be executed depending on different cases
    > throw	                    Throws (generates) an error
    > try ... catch ... finally	    Marks the block of statements to be executed when an error occurs in a try block, and implements error handling
    > var	                          Declares a variable
    > while	                    Marks a block of statements to be executed while a condition is true    
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Math Object Methods and Properties: Javascript provee el objeto Math que funciona como un contenedor de herramientas y métodos para realizar operaciones matemáticas

    > abs(x)	      Returns the absolute value of x
    > acos(x)	      Returns the arccosine of x, in radians
    > acosh(x)	      Returns the hyperbolic arccosine of x
    > asin(x)	      Returns the arcsine of x, in radians
    > asinh(x)	      Returns the hyperbolic arcsine of x
    > atan(x)	      Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
    > atan2(y, x)	  Returns the arctangent of the quotient of its arguments
    > atanh(x)	      Returns the hyperbolic arctangent of x
    > cbrt(x)	      Returns the cubic root of x
    > ceil(x)	      Returns x, rounded upwards to the nearest integer
    > clz32(x)	      Returns the number of leading zeros in a 32-bit binary representation of x
    > cos(x)	      Returns the cosine of x (x is in radians)
    > cosh(x)	      Returns the hyperbolic cosine of x
    > E	              Returns Euler's number (approx. 2.718)
    > exp(x)	      Returns the value of Ex
    > expm1(x)	      Returns the value of Ex minus 1
    > floor(x)	      Returns x, rounded downwards to the nearest integer
    > fround(x)	      Returns the nearest (32-bit single precision) float representation of a number
    > LN2	          Returns the natural logarithm of 2 (approx. 0.693)
    > LN10	          Returns the natural logarithm of 10 (approx. 2.302)
    > log(x)	      Returns the natural logarithmof x
    > log10(x)	      Returns the base-10 logarithm of x
    > LOG10E	      Returns the base-10 logarithm of E (approx. 0.434)
    > log1p(x)	      Returns the natural logarithm of 1 + x
    > log2(x)	      Returns the base-2 logarithm of x
    > LOG2E	          Returns the base-2 logarithm of E (approx. 1.442)
    > max(x1,x2,..)	  Returns the number with the highest value
    > min(x1,x2,..)	  Returns the number with the lowest value
    > PI	            Returns PI (approx. 3.14)
    > pow(x, y)	      Returns the value of x to the power of y
    > random()	      Returns a random number between 0 and 1. Para generar números aleatorios dentro de un rango deseado, distinto de 0-1, podemos multiplicar su resultado por el rango esperado. A la vez podemos sumar el límite inferior.
                      console.log( Math.random() * 10 )// números entre 0 y 10
                      console.log( Math.random() * 50) // números entre 0 y 50
                      console.log( Math.random() * 30 + 20 ) // números entre 20 y 50
    > round(x)	      Rounds x to the nearest integer
    > sign(x)	      Returns the sign of a number (checks whether it is positive, negative or zero)
    > sin(x)	      Returns the sine of x (x is in radians)
    > sinh(x)	      Returns the hyperbolic sine of x
    > sqrt(x)	      Returns the square root of x
    > SQRT1_2	      Returns the square root of 1/2 (approx. 0.707)
    > SQRT2	          Returns the square root of 2 (approx. 1.414)
    > tan(x)	      Returns the tangent of an angle
    > tanh(x)	      Returns the hyperbolic tangent of a number
    > trunc(x)	      Returns the integer part of a number (x)


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Number                      
  
constructor	       Returns the function that created JavaScript's Number prototype
EPSILON	            Returns the difference between 1 and the smallest number greater than 1
isFinite()	            Checks whether a value is a finite number
isInteger()	       Checks whether a value is an integer
isNaN()	            Checks whether a value is Number.NaN
isSafeInteger()	      Checks whether a value is a safe integer
MAX_SAFE_INTEGER      Returns the maximum safe integer in JavaScript.
MIN_SAFE_INTEGER      Returns the minimum safe integer in JavaScript
MAX_VALUE	           Returns the largest number possible in JavaScript
MIN_VALUE	           Returns the smallest number possible in JavaScript
NaN	                Represents a "Not-a-Number" value
NEGATIVE_INFINITY	Represents negative infinity (returned on overflow)
POSITIVE_INFINITY	Represents infinity (returned on overflow)
parseFloat()	     Parses a string an returns a number
parseInt()	          Parses a string an returns a whole number
prototype	          Allows you to add properties and methods to an object
toExponential(x)	    Converts a number into an exponential notation
toFixed(x)	          Formats a number with x numbers of digits after the decimal point
toLocaleString()	     Converts a number into a string, based on the locale settings
toPrecision(x)	    Formats a number to x length
toString()	         Converts a number to a string
valueOf()	         Returns the primitive value of a number

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

- Built-in JavaScript Constructors

new String()    // Create a new String object
new Number()    // Create a new Number object
new Boolean()   // Create a new Boolean object
new Object()    // Create a new Object object
new Array()     // Create a new Array object
new RegExp()    // Create a new RegExp object
new Function()  // Create a new Function object
new Date()      // Create a new Date object


As you can see above, JavaScript has object versions of the primitive data types String, Number, and Boolean. But there is no reason to create complex objects. Primitive values are much faster:
Use string literals "" instead of new String().
Use number literals 50 instead of new Number().
Use boolean literals true / false instead of new Boolean().
Use object literals {} instead of new Object().
Use array literals [] instead of new Array().
Use pattern literals /()/ instead of new RegExp().
Use function expressions () {} instead of new Function().
        
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
    
- JavaScript date reference
    > constructor	             Returns the function that created the Date object's prototype
    > getDate()	               Returns the day of the month (from 1-31)
    > getDay()	               Returns the day of the week (from 0-6)
    > getFullYear()	           Returns the year
    > getHours()	             Returns the hour (from 0-23)
    > getMilliseconds()	       Returns the milliseconds (from 0-999)
    > getMinutes()	           Returns the minutes (from 0-59)
    > getMonth()	             Returns the month (from 0-11)
    > getSeconds()	           Returns the seconds (from 0-59)
    > getTime()	               Returns the number of milliseconds since midnight Jan 1 1970, and a specified date
    > getTimezoneOffset()	     Returns the time difference between UTC time and local time, in minutes
    > getUTCDate()	           Returns the day of the month, according to universal time (from 1-31)
    > getUTCDay()	             Returns the day of the week, according to universal time (from 0-6)
    > getUTCFullYear()	       Returns the year, according to universal time
    > getUTCHours()	           Returns the hour, according to universal time (from 0-23)
    > getUTCMilliseconds()	   Returns the milliseconds, according to universal time (from 0-999)
    > getUTCMinutes()	         Returns the minutes, according to universal time (from 0-59)
    > getUTCMonth()	           Returns the month, according to universal time (from 0-11)
    > getUTCSeconds()	         Returns the seconds, according to universal time (from 0-59)
    > now()	                   Returns the number of milliseconds since midnight Jan 1, 1970
    > parse()	                 Parses a date string and returns the number of milliseconds since January 1, 1970
    > prototype	               Allows you to add properties and methods to an object
    > setDate()	               Sets the day of the month of a date object
    > setFullYear()	           Sets the year of a date object
    > setHours()	             Sets the hour of a date object
    > setMilliseconds()	       Sets the milliseconds of a date object
    > setMinutes()	           Set the minutes of a date object
    > setMonth()	             Sets the month of a date object
    > setSeconds()	           Sets the seconds of a date object
    > setTime()	               Sets a date to a specified number of milliseconds after/before January 1, 1970
    > setUTCDate()	           Sets the day of the month of a date object, according to universal time
    > setUTCFullYear()	       Sets the year of a date object, according to universal time
    > setUTCHours()	           Sets the hour of a date object, according to universal time
    > setUTCMilliseconds()	   Sets the milliseconds of a date object, according to universal time
    > setUTCMinutes()	         Set the minutes of a date object, according to universal time
    > setUTCMonth()	           Sets the month of a date object, according to universal time
    > setUTCSeconds()	         Set the seconds of a date object, according to universal time
    > toDateString()	         Converts the date portion of a Date object into a readable string
    > toISOString()	           Returns the date as a string, using the ISO standard
    > toJSON()	               Returns the date as a string, formatted as a JSON date
    > toLocaleDateString()	   Returns the date portion of a Date object as a string, using locale conventions
    > toLocaleTimeString()	   Returns the time portion of a Date object as a string, using locale conventions
    > toLocaleString()	       Converts a Date object to a string, using locale conventions
    > toString()	             Converts a Date object to a string
    > toTimeString()	         Converts the time portion of a Date object to a string
    > toUTCString()	           Converts a Date object to a string, according to universal time
    > UTC()	                   Returns the number of milliseconds in a date since midnight of January 1, 1970, according to UTC time
    > valueOf()	               Returns the primitive value of a Date object
   
    
- La clase Date: Seguramente en algún momento necesitemos manipular fechas dentro de los datos que manejamos. Para esto, JavaScript posee la clase Date diseñada para representar fechas.
  ~ Date: Instanciar un objeto Date nos genera la fecha y tiempo actual
    console.log(new Date())  //Fri Dec 17 2021 11:35:08 GMT-0300 (hora estándar de Argentina
    
  ~ Constructor: El constructor de la clase Date nos permite crear objetos date confechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    La convención con la que trabaja Javascript para construir fechas cuenta los meses a partir del 0 (0 = enero, 11 = diciembre) y los días a partir del 1:
    
    console.log(new Date(2020, 1, 15)) // Sat Feb 15 2020 00:00:00 GMT-0300 (hora estándar de Argentina)
    const casiNavidad = new Date(2021, 11, 25, 23, 59, 59)
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)

    El constructor de la clase Date nos permite crear objetos date con fechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    
    const casiNavidad = new Date("December 25, 2021 23:59:59" )
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)
    
  ~ Obtener un valor singular de la fecha: Instanciado un objeto Date, podemos aplicar distintos métodos que nos evuelven determinados valores de la misma. 
    + getMonth(); nos retornará el number que representa el mes (entre 0 y 11)
    + getFullYear(); nos devolverá el number que representa el año creado
    + getDay(); nos retornará el number que representa el día creado (1 = lunes, 7 = domingo)
      
      const hoy = new Date("December 17, 2021")
      console.log(hoy.toDateString()) // Fri Dec 17 2021
      console.log(hoy.toLocaleString()) // 17/12/2021 00:00:00
      console.log(hoy.toLocaleDateString()) // 17/12/2021
      console.log(hoy.toTimeString()) // 00:00:00 GMT-0300 (hora estándar de Argentina)
      
  ~ Diferencias entre fechas: ;os resultados de las diferencias entre fechas se generan en milisegundos. Si quisiera calcular la diferencia de días entre dos fechas habría que generar cálculos adicionales sobre esta diferencia en 
    milisegundos. Por suerte, existen librerías que solucionan estos problemas de forma eficiente y rápida, pero las trabajaremos en clases posteriores.
    
    const navidad = new Date("December 25, 2021")
    const hoy = new Date("December 17, 2021")
    console.log( navidad - hoy ) // 691200000
    const milisegundosPorDia = 86400000
    console.log( (navidad - hoy ) / milisegundosPorDia) // 8
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
-  Sets and Map Methods

   ~ Map: Un Map es una colección de pares tipo clave-valor (como un objeto) donde la clave puede ser de cualquier tipo, siendo la principal diferencia con un objeto, además de ciertos métodos que permiten una simple manipulación proveyendo 
      una forma eficiente de buscar y obtener datos. Además un Map permite que se agreguen datos de forma dinámica. Además Map incluye algunos métodos que te permiten iterar sobre los elementos del mismo, estos métodos retornan un tipo 
      MapIterator que permite el uso de loops for-of o forEach directamente.
      
      Si bien son estructuras de datos similares hay ciertos momentos para decantar por uno u otro usa Map cuando:
        1) Necesitas almacenar información en donde las claves no son siempre strings.
        2) Necesitas una estructura de datos donde los objetos pueden ser ordenados.
        3) Necesitas realizar búsquedas eficientes en los datos (sin utilizar librerías externas).
        
   ~ Set: Es una colección de elementos unicos que pueden ser de cualquier tipo, muy similar a un arreglo. Esta también es una colección ordenada de elementos. Puedes crear e inicializar un Set usando new. Al igual que Map, Set también tiene 
      métodos que te permiten agregar o eliminar elementos del mismo. Set también cuenta con el método Set.has(element) para saber si un element está o no en un set, además del método Set.delete(element) para eliminar un elemento. Para 
      iterar sobre un Set puedes usar el método Set.values() que retorna un SetIterator, sobre este iterador puedes utilizar forEach o for-of. Set y Array son similarres y puedes convertirlos entre sí utilizando el operador spread.
   
   

    > new Set()	       Creates a new Set
    > add()	           Adds a new element to the Set
    > delete()	       Removes an element from a Set
    > has()	           Returns true if a value exists
    > clear()	       Removes all elements from a Set
    > forEach()	       Invokes a callback for each element
    > values()	       Returns an Iterator with all the values in a Set
    > keys()	       Same as values()
    > entries()	       Returns an Iterator with the [value,value] pairs from a Set

    > new Map()	      Creates a new Map object
    > set()	       Sets the value for a key in a Map
    > get()	       Gets the value for a key in a Map
    > clear()	       Removes all the elements from a Map
    > delete()	       Removes a Map element specified by a key
    > has()	       Returns true if a key exists in a Map
    > forEach()	       Invokes a callback for each key/value pair in a Map
    > entries()	      Returns an iterator object with the [key, value] pairs in a Map
    > fromEntries()    method creates an object from iterable key / value pairs.
    > keys()	       Returns an iterator object with the keys in a Map
    > values()	      Returns an iterator object of the values in a Map
    
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
    
-  Métodos de los STRINGS

    > charAt()	            Returns the character at a specified index (position)
    > charCodeAt()	        Returns the Unicode of the character at a specified index
    > concat()	            Returns two or more joined strings
    > constructor	        Returns the string's constructor function
    > endsWith()	            Returns if a string ends with a specified value
    > fromCharCode()	      Returns Unicode values as characters
    > includes()	           Returns true or false if a string contains a specified value
    > indexOf()	            Returns the index (position) of the first occurrence of a value in a string
    > lastIndexOf()	        Returns the index (position) of the last occurrence of a value in a string
    > length	            Returns the length of a string
    > localeCompare()	       Compares two strings in the current locale
    > match()	            Searches a string for a value, or a regular expression, and returns the matches
    > padStart()            method pads a string from the start. And also pads a string with another string (multiple times) until it reaches a given length.
    > padEnd()              method pads a string at the end. And also pads a string with another string (multiple times) until it reaches a given length.
    > prototype	            Allows you to add properties and methods to an object
    > repeat()	            Returns a new string with a number of copies of a string
    > replace()	            Searches a string for a value, or a regular expression, and returns a string where the values are replaced
    > replaceAll()	       Searches a string for a pattern and returns a new string where all matches are replaced
    > search()	            Searches a string for a value, or regular expression, and returns the index (position) of the match
    > slice()	            Extracts a part of a string and returns a new string
    > split()	            Splits a string into an array of substrings. Returns the new array, does not change the original string. If (" ") is used as separator, the string is split between words.
    > startsWith()	        Checks whether a string begins with specified characters
    > substr()	            Extracts a number of characters from a string, from a start index (position)
    > substring()	        Extracts characters from a string, between two specified indices (positions)
    > toLocaleLowerCase()	  Returns a string converted to lowercase letters, using the host's locale
    > toLocaleUpperCase()	 Returns a string converted to uppercase letters, using the host's locale
    > toLowerCase()	        Returns a string converted to lowercase letters
    > toString()	             Returns a string or a string object as a string
    > toUpperCase()	        Returns a string converted to uppercase letters
    > trim()	            Returns a string with removed whitespaces
    > trimEnd()	            Returns a string with removed whitespaces from the end
    > trimStart()	        Returns a string with removed whitespaces from the start
    > valueOf()	            Returns the primitive value of a string or a string object
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
       

- Métodos y propiedades de las ARRAYS

    > at()        	Returns an indexed element of an array

    > concat()	      Joins arrays and returns an array with the joined arrays. Mediante el método concat podemos combinar dos Arrays en un único Array resultante. se usa para unir dos o más arrays. Este método no cambia los arrays 
                      existentes, sino que devuelve un nuevo array.
   
    > constructor     Returns the function that created the Array object's prototype
   
    > copyWithin()    Copies array elements within the array, to and from specified positions
   
    > entries()	      Returns a key/value pair Array Iteration Object
   
    > every()	      Checks if every element in an array pass a test
   
    > fill()	      Fill the elements in an array with a static value
    
    > flat()	      Concatenates sub-array elements
    
    > flatMap()	      Maps all array elements and creates a new flat array
    
    >* filter()	      Creates a new array with every element in an array that pass a test. Consiste en filtrar uno o más elementos (un subconjunto) de una colección más grande de elementos (un superconjunto) basándose en alguna 
                      condición/preferencia. Recibe, al igual que find(), una función comparadora por parámetro, y retorna un nuevo array con todos los elementos que cumplan esa condición. Si no hay coincidencias, retornará un array vacío.
                      Toma una función callback y llama a esa función para cada elemento sobre el que itera dentro del arreglo de destino. La función callback de llamada puede tomar los siguientes parámetros:
                      1- valorActual: Es el elemento del arreglo sobre el que se está iterando actualmente. 2- indice: Es la posición del índice del valorActual dentro del arreglo. 3- arreglo: Representa el arreglo de destino(final) junto 
                      con todos sus elementos. Este método crea un nuevo arreglo y devuelve todos los elementos que pasan la condición especificada en la llamada en el callback.
                      
    >* find()	      Returns the value of the first element in an array that pass a test. Recibe una función de comparación por parámetro. Captura el elemento que se está recorriendo y retorna true o false según la comparación ejecutada, o 
                      bien el objeto donde se encuentra lo que estamos buscando. El método retorna el primer elemento que cumpla con esa condición enviada, de ahí que podemos almacenarlo en una variable o usarlo de referencia para otro 
                      proceso. Si no hay ninguna coincidencia en el array, el método find retorna undefined.
                      Toma una función de callback y llama a esa función para cada elemento que recorre dentro del arreglo al que está vinculado. Cuando encuentra una coincidencia (en otras palabras, la función callback devuelve true), el 
                      método devuelve ese elemento particular del arreglo e inmediatamente rompe el bucle. Así que el método find() devuelve el primer elemento dentro de un arreglo que satisface la función callback. 
                      La función callback puede tomar los siguientes parámetros: 1- currentItem: Es el elemento del arreglo sobre el que se está iterando actualmente. 2- index: Esta es la posición de índice de currentItem dentro del arreglo. 
                      3- array: Representa el arreglo de destino junto con todos sus elementos.

    >* findIndex()    Returns the index of the first element in an array that pass a test. It executes a function for each array element. It returns the index (position) of the first element that passes a test. It returns -1 if no match is 
                      found. It does not execute the function for empty array elements. It does not change the original array.
    
    >* forEach()	      Calls a function for each array element. Itera sobre el array y por cada elemento ejecuta la función que enviemos por parámetro, la cual recibe a su vez el elemento del array que se está recorriendo. 
                      Es muy similar al for of, pero con la diferencia de que aqui no podemos salir de la iteracion, mientras qu con for of si.
                      Este a diferencia del map, sirve para ejecutar instrucciones en una iteracion, mientras que el map devuelve un array en cada vuelta.
    
    > for in          Loops through the properties of an object Permite acceder a todas las propiedades del objeto, obteniendo una propiedad por cada iteración. (Solo sirve para iterar objetos). Iterates over all enumerable string properties 
                      of an object (ignoring properties keyed by symbols), including inherited enumerable properties.
    
    > for of          Loops through the values of an iterable object. Permite recorrer un array ejecutando un bloque de código por cada elemento del objeto. (Solo sirve para iterar arrays). It executes a loop that operates on a sequence of 
                      values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), the arguments object, generators produced by 
                      generator functions, and user-defined iterables. 
    
    
    > from()	      Creates an array from an object
    
    > includes()	      Check if an array contains the specified element. Permite saber si un elemento que recibo por parámetro existe o no dentro de un array, retornando un valor booleano en caso afirmativo o negativo.
   
    > indexOf()	      Search the array for an element and returns its position. El método indexOf() nos permite obtener el índice de un elemento en un array. Recibe por parámetro el elemento que queremos buscar en el array y, en caso de 
                      existir, nos retorna su índice. Si el elemento no existe nos retornará como valor: -1
   
    > isArray()	      Checks whether an object is an array
   
    > join()	      Joins all elements of an array into a string. Sirve para generar un string con todos los elementos del array, separados por el valor que pasamos por parámetro
   
    > keys()	      Returns a Array Iteration Object, containing the keys of the original array
   
    > lastIndexOf()   Search the array for an element, starting at the end, and returns its position
    
    > length	      Sets or returns the number of elements in an array. Al igual que en un String, la propiedad length nos sirve para obtener el largo de un Array, es decir, para identificar cuántos elementos tiene. Es común utilizarlo 
                      para definir el límite de una iteración sobre un array, ya que la propiedad length me permite saber explícitamente la longitud del mismo.
    
    >* map()	      Creates a new array with the result of calling a function for each array element. El método map() crea un nuevo array con todos los elementos del original transformados según las operaciones de la función enviada por 
                      parámetro. Tiene la misma cantidad de elementos pero los almacenados son el return de la función. En el ejemplo, la función retorna la propiedad nombre de cada elemento y eso es lo que se almacena en el nuevo array 
                      nombres. Map() se utiliza mucho para transformación de arrays. Este a diferencia del for each, es que devuelve un array en cada vuelta, mientras que el foreach solo sirve para ejecutar instrucciones.
                      En REACT, debemos incluir en cada elemento la propiedad key, que marque la identidad del elemento. Esto ayudará a react a optimizar el rendering ante cambios en el array. De no tenerla podemos auto-generarla con el 
                      index provisto por el segundo parámetro de map, pero sólo optimizará si hay adiciones al final del array.
    
    > pop()	      Removes the last element of an array, and returns that element. Si queremos eliminar el último elemento, el método pop().
   
    > prototype	      Allows you to add properties and methods to an Array object
    
    > push()	      Adds new elements to the end of an array, and returns the new length. Para sumar un elemento a un Array ya existente, se utiliza el método push, pasando como parámetro el valor (o variable) a agregar.
   
    >* reduce()	      Reduce the values of an array to a single value (going left-to-right). Permite obtener un único valor tras iterar sobre el array. Funciona como un método que resume el array a un único valor de retorno. Este recibe dos 
                      parámetros: 
                      1.El primero es la función que ordena qué queremos resumir del array. Recibe un parámetro que funciona como acumulador, y el elemento del array que iteramos. 
                      2.El segundo es el valor inicial del acumulador.
    
   
    > reduceRight()   Reduce the values of an array to a single value (going right-to-left)
    
    > reverse()	      Reverses the order of the elements in an array. Invierte el orden de los elementos dentro de un array. (es destructivo, o sea que modifica el array original, al igual que los métodos para agregar o quitar elementos).
    
    > shift()	      Removes the first element of an array, and returns that element. Si queremos eliminar el primer elemento del array utilizamos el método shift();
    
    > slice()	      Selects a part of an array, and returns the new array. Devuelve una copia de una parte del Array dentro de un nuevo Array, empezando por el inicio hasta fin (fin no incluído). El Array original no se modificará. Si 
                      elegimos un valor negativo, por ejemplo (1, -2), se lee como "Empiza en la posicion 1 y los ultimos dos valores no los considera". O bien, si tenemos (-2), quiere decir que tomamos los ultimos dos valores del array.
    
    >* some()	      Checks if any of the elements in an array pass a test. Es igual que el find() recibiendo una función de búsqueda. En vez de retornar el elemento encontrado, retorna true o false según el resultado de la iteración. 
                      Analiza cada elemento de un array a partir de la función que le pasemos. Como su nombre indica, este método nos devolverá el resultado true cuando alguno de los elementos del array cumpla la condición insertada. De 
                      manera lógica, este método nos devolverá el resultado false solo si ninguno de los elementos del array cumple con la condición. Para usar el método some, insertamos el mismo comando de cualquier método array.método. 
                      Luego, entre sus paréntesis, insertamos la función que queremos usar como condición a analizar. Para usar una función como parámetro, podemos insertar su operación directamente o llamarla por su nombre.
    
    >* sort()	      Sorts the elements of an array. Permite reordenar un array según un criterio que definamos. Recibe una función de comparación por parámetro que, a la vez, recibe dos elementos del array. La función 
                      retorna un valor numérico (-1, 1, 0) que indica qué elemento se posiciona antes, después o se mantieneigual. Este método es destructivo, es decir, modifica el array sobre el cual se llama. Para ordenar números, basta 
                      con restar uno al otro, y el orden indica si será ordenado de forma ascendente o descendente. Para ordenar un array por algún string, debemos definir una función comparadora que retorne un valor numérico de referencia, 
                      según queramos el orden ascendente o descendente. No se necesita crear una variable cuando utilicemos este metodo, puesto que el array original mismo es el que se modifica.
    
    > splice()	      Adds/Removes elements from an array. Permite eliminar uno o varios elementos de un array en cualquier posición. Funciona con 2 parámetros: el primero es el índice donde se ubica el método para trabajar, y el segundo es 
                      la cantidad de elementos a eliminar desde esa posición.
    > toString()	      Converts an array to a string, and returns the result
    > unshift()	      Adds new elements to the beginning of an array, and returns the new length. Agrega elementos al inicio del array.
    > valueOf()	      Returns the primitive value of an array
    
    > for in vs for of        En el caso de for in, este devuelve un numero (indice) y se usa generalmente en objetos, y el for of conseguimos el valor que hay en esa posicion.
    
    > arrays vs objetos       Los objetos no son iterables mientras que las arrays sí lo son. Los objetos tienen keys de cualquier valor, los arrays tienen keys numéricos y por estricto orden
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
   
  
  > Estructura DOM: 
    ~ Cada etiqueta HTML se transforma en un nodo de tipo "Elemento". La conversión se realiza de forma jerárquica. 
    ~ De esta forma, del nodo raíz solamente pueden derivar los nodos HEAD y BODY.
    ~ Cada etiqueta HTML se transforma en un nodo que deriva del correspondiente a su "etiqueta padre".
    ~ La transformación de las etiquetas HTML habituales genera dos nodos"
      + Nodo elemento: correspondiente a la propia etiqueta HTML.
      + Nodo texto: contiene el texto encerrado por esa etiqueta HTML.
      
  > Tipos de Nodos: La especificación completa de DOM define 12 tipos de nodos, los más usados son:
    ~ Document: Nodo raíz del que derivan todos los demás nodos del  árbol.
    ~ Element: Representa cada una de las etiquetas XHTML. Puede contener atributos y derivar otros nodos de él.
    ~ Attr: Se define un nodo de este tipo para representar cada uno de los atributos de las etiquetas HTML, es decir, uno por cada par atributo=valor.
    ~ Text: Nodo que contiene el texto encerrado por una etiqueta  HTML.
    ~ Comment: Representa los comentarios incluidos en la página HTML.
    
  > Modificar Nodos: En esta seccion se pude modificar un solo nodo con las siguientes comandos.
    ~ Inner Text: La propiedad innerText de un nodo nos permite modificar su nodo de texto. Es decir, acceder y/o modificar el contenido textual de algún elemento del DOM.
    ~ Inner HTML: permite definir el código html interno del elemento seleccionado. El navegador lo interpreta como código HTML y no como contenido de texto, permitiendo desde un string crear una nueva estructura de etiquetas y contenido.
      Al pasar un string con formato de etiquetas html y contenido a través de la propiedad innerHTML, el navegador genera nuevos nodos con su contenido dentro del elemento seleccionado.
    ~ Class Name: A través de la propiedad className de algún nodo seleccionado podemos acceder al atributo class del mismo y definir cuáles van a ser sus clases.
    
  > Agregar o quitar Nodos: 
    ~ Creación de elementos: Para crear elementos se utiliza la función document.createElement(), y se debe indicar el nombre de etiqueta HTML que representará ese elemento. Luego debe agregarse como hijo el nodo creado con append(), al body 
      o a otro nodo del documento actual.
    ~ Eliminar elementos: Se pueden eliminar nodos existentes y nuevos. El método remove() permite eliminar un nodo seleccionado del DOM.
    ~ Obtener datos de Inputs: Para obtener o modificar datos de un formulario HTML desde JS, podemos hacerlo mediante el DOM. Accediendo a la propiedad value de cada input seleccionado.
    
  > Plantillas de texto
    ~ Plantillas Literales: En versiones anteriores a ES6, solía emplearse la concatenación para incluir valores de las variables en una cadena de caracteres (string). Esta forma puede ser poco legible ante un gran número de referencias. En 
      JS ES6 que solventa esta situación son los template strings.
      
    ~ Plantillas Literales e innerHTML: La plantillas son un medio para incluir variables en la estructura HTML de nodos nuevos o existentes , modificando el innerHTML.
    
    ~ Query Selector: El método querySelector() nos permite seleccionar nodos con la misma sintaxis que utilizamos en los selectores de CSS. 
      Lo interesante del querySelector es que también aplica a pseudo-clases de CSS, brindando un nivel más avanzado de precisión:
      let radioChecked = document.querySelector(".radio:checked") 
      Suponiendo que tengo elementos html radio button y quiero seleccionar sólo aquel que esté en checked, ésto lo puedo lograr muy fácil con querySelector y la pseudo-clase :checked de CSS.

    ~ Query Selector All: Query Selector me retorna el primer elemento que coincida con el parámetro de búsqueda, o sea un sólo elemento. Si quiero obtener una colección de elementos puedo utilizar el método querySelectorAll() siguiendo el 
      mismo comportamiento
    
  > Acceder a los Nodos: Existen distintos métodos para acceder a los elementos del DOM empleando en la clase Document.
    ~ getElementById();          The getElementById() method of the Document interface returns an Element object representing the element whose id property matches the specified string. Since element IDs are required to be unique if
                                 specified, they're a useful way to get access to a specific element quickly. If you need to get access to an element which doesn't have an ID, you can use querySelector() to find the element using any 
                                 selector. Sirve para acceder a un elemento de la estructura HTML, utilizando su atributo ID como identificación.
    ~ getElementsByClassName();  The getElementsByClassName method of Document interface returns an array-like object of all child elements which have all of the given class name(s). When called on the document object, the complete document 
                                 is searched, including the root node. You may also call getElementsByClassName() on any element; it will return only elements which are descendants of the specified root element with 
                                 the given class name(s). Sirve para acceder a un conjunto de elementos de la estructura HTML, utilizando su atributo class como identificación. Se retornará un Array de elementos con todas las coincidencias:
    ~ getElementsByTagName();    The getElementsByTagName method of Document interface returns an HTMLCollection of elements with the given tag name. The complete document is searched, including the root node. The returned HTMLCollection is 
                                 live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call document.getElementsByTagName() again. Sirve para acceder a un conjunto de elementos de la 
                                 estructura HTML, utilizando su nombre de etiqueta como identificación. Esta opción es la menos específica de todas, ya que es muy probable que las etiquetas se repitan en el código HTML.

- Eventos: Los eventos son la manera que tenemos en Javascript de controlar las acciones de los usuarios, y definir un comportamiento de la página o aplicación cuando se produzcan. Con Javascript es posible definir qué sucede cuando se 
  produce un evento, por ejemplo, cuando se realiza un clic en cierto elemento o se inserta un texto en un determinado campo.
  JavaScript permite asignar una función a cada uno de los eventos. Reciben el nombre de event handlers o manejadores de eventos. Así, ante cada evento, JavaScript asigna y ejecuta la función asociada al mismo.
  Hay que entender que los eventos suceden constantemente en el navegador. JavaScript lo que nos permite hacer es escuchar eventos sobre elementos seleccionados. Cuando escuchamos el evento que esperamos, se ejecuta la función que definimos 
  en respuesta. A esta escucha se la denomina event listener.
  
  > ¿Cómo definir eventos en JS?: 
    ~ El método addEventListener() permite definir qué evento escuchar sobre cualquier elemento seleccionado. El primer parámetro corresponde al nombre del evento y el segundo a la función de respuesta
    ~ Emplear una propiedad del nodo para definir la respuesta al evento. Las propiedades se identifican con el nombre del evento y el prefijo on. También es posible emplear funciones anónimas para definir los manejadores de eventos.
  
  > Eventos más comunes: 
    ~ mouse: Se producen por la interacción del usuario con el mouse. Entre ellos se destacarán los que se encuentran a continuación.
      ✓ mousedown/mouseup: Se oprime/suelta el botón del ratón sobre un elemento.
      ✓ mouseover/mouseout: El puntero del mouse se mueve sobre/sale del elemento.
      ✓ mousemove: El movimiento del mouse sobre el elemento activa el evento. 
      ✓ click: Se activa después de mousedown o mouseup sobre un elemento válido.

    ~ teclado: Se producen por la interacción del usuario con el teclado. Entre ellos se destacarán los que se encuentran a continuación.
      ✓ keydown: Cuando se presiona.
      ✓ keyup: Cuando se suelta una tecla.
      
    ~ change: Se activa cuando se detecta un cambio en el valor del elemento.  Por ejemplo, mientras se escribe en un input de tipo texto no hay evento change, pero cuando se pasa a otra sección de la aplicación entonces sí ocurre. 

    ~ input: Si queremos ejecutar una función cada vez que se tipea sobre el campo, conviene trabajar directamente con el evento input.

    ~ submit: El evento submit se activa cuando el formulario es enviado. Normalmente se utiliza para validar el formulario antes de ser enviado al servidor o bien para abortar el envío y procesarlo con JavaScript
 
- JSON & storage: 
   > storage: El objeto Storage (API de almacenamiento web) permite almacenar datos de manera local en el navegador sin necesidad de realizar ninguna conexión con el servidor. De esta manera, cada cliente puede preservar información de la 
     aplicación. El navegador nos ofrece dos tipos de storage: localStorage y sessionStorage.
   > localstorage.Setitem(); Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren los datos de navegación del browser). La información persiste reinicio 
     de navegador y hasta del sistema operativo.
   > Clave-valor: La información almacenada en el Storage se guarda en la forma de clave-valor. Similar al tratamiento de objetos, definimos claves en el storage donde almacenamos valores.
   > localstorage.getItem(); Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > localstorage.setItem(); La información almacenada en sessionStorage (variable global preexistente) se almacena en el navegador hasta que el usuario cierra la ventana. Solo existe dentro de la pestaña actual del navegador. Otra pestaña 
     con la misma página tendrá otro sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen).
   > sessionStorage.getItem(); Podemos acceder a la información almacenada en sessionStorage utilizando getItem. Las claves y valores de Storage se guardan siempre en formato de cadena de caracteres
   > Recorriendo el storage: Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle. Pero no podemos usar for of porque no son objetos iterables, ni for in porque obtenemos otras propiedades del 
     objeto que no son valores almacenados.
   > Eliminar datos del storage: Podemos eliminar la información almacenada en sessionStorage o localStorage usando el método removeItem o clear. 
     ~ localStorage.removeItem(); 
     ~ sessionStorage.removeItem();
     ~ localStorage.clear(); //elimina toda la información
     ~ sessionStorage.clear(); //elimina toda la información
     
   > Almacenar objetos en storage Si queremos almacenar la información de un objeto en un storage, hay que tener en cuenta que tanto la clave como el valor se almacenan en strings. Ante cualquier otro tipo a guardar, como un número o un 
     objeto, se convierte a cadena de texto automáticamente. Entonces, al buscar almacenar un objeto sin una transformación previa, guardamos [object Object], la conversión por defecto de objeto a string. Para guardar la información 
     correctamente hay que transformar el objeto a JSON.
   > Acceso tipo objeto Dado que localStorage y sessionStorage son objetos globales, es posible crear y acceder a las claves como si fueran propiedades. Pero esto no es recomendable, porque hay eventos asociados a la modificación del storage 
     cuando se emplea getItem o setItem.
         
   > Conversiones de/hacia JSON: Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado.
     Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado. Para eso usamos los siguientes métodos:
     
     ~ JSON.stringify(); acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON. 
       Los parametros que existen en esta funcion son:            JSON.stringify(value, replacer, space);
       + value: The value to convert to a JSON string
       + replacer: function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that 
         are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g. null or not provided), all string-keyed properties 
         of the object are included in the resulting JSON string.
       + space: A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes. If this is a number, it indicates the number of space characters 
         to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
         If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array. If space is anything other than a string or number (can be either a primitive or a 
         wrapper object) — for example, is null or not provided — no white space is used.
         
       This static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.

     ~ JSON.parse(); recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript. 
       Los parametros que existen en esta funcion son:            JSON.parse(text, reviver);    
        + text: The string to parse as JSON. See the JSON object for a description of JSON syntax.
        + reviver: If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments: key and value.
       
       This static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.

   
   > Recuperar datos: Muchas veces usamos el Storage para recuperar datos relacionados a la última navegación del usuario. Por ejemplo, su última sesión de login o el último estado de su carrito de compras. Para esto, pensamos en inicializar 
     las variables de la app consultando el Storage en el momento de inicio.
     
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


- Propiedades del objeto WINDOW

    > closed	        Returns a boolean true if a window is closed.
    > console	        Returns the Console Object for the window.
    > document	        Returns the Document object for the window.
    > frameElement	   Returns the frame in which the window runs.
    > frames	        Returns all window objects running in the window.
    > history	        Returns the History object for the window.
    > innerHeight	    Returns the height of the window's content area (viewport) including scrollbars
    > innerWidth	         Returns the width of a window's content area (viewport) including scrollbars
    > length	        Returns the number of <iframe> elements in the current window
    > localStorage	   Allows to save key/value pairs in a web browser. Stores the data with no expiration date
    > location	        Returns the Location object for the window.
    > name	             Sets or returns the name of a window
    > navigator	        Returns the Navigator object for the window.
    > opener	        Returns a reference to the window that created the window
    > outerHeight	    Returns the height of the browser window, including toolbars/scrollbars
    > outerWidth	         Returns the width of the browser window, including toolbars/scrollbars
    > pageXOffset	    Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
    > pageYOffset	    Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
    > parent	        Returns the parent window of the current window
    > screen	        Returns the Screen object for the window
    > screenLeft	        Returns the horizontal coordinate of the window relative to the screen
    > screenTop	        Returns the vertical coordinate of the window relative to the screen
    > screenX	        Returns the horizontal coordinate of the window relative to the screen
    > screenY	        Returns the vertical coordinate of the window relative to the screen
    > sessionStorage	   Allows to save key/value pairs in a web browser. Stores the data for one session
    > scrollX	        An alias of pageXOffset
    > scrollY	        An alias of pageYOffset
    > self	              Returns the current window
    > top	             Returns the topmost browser window

- Métodos del objeto WINDOW

    > addEventListener()         Attaches an event handler to the window
    > alert()	                 Displays an alert box with a message and an OK button
    > atob()	                 Decodes a base-64 encoded string
    > blur()	                 Removes focus from the current window
    > btoa()	                 Encodes a string in base-64
    > clearInterval()            Clears a timer set with setInterval()
    > clearTimeout()             Clears a timer set with setTimeout()
    > close()	                 Closes the current window
    > confirm()	                 Displays a dialog box with a message and an OK and a Cancel button
    > focus()	                 Sets focus to the current window
    > getComputedStyle()	      Gets the current computed CSS styles applied to an element
    > getSelection()             Returns a Selection object representing the range of text selected by the user
    > matchMedia()               Returns a MediaQueryList object representing the specified CSS media query string
    > moveBy()	                 Moves a window relative to its current position
    > moveTo()	                 Moves a window to the specified position
    > open()	                 Opens a new browser window
    > print()	                 Prints the content of the current window
    > prompt()	                 Displays a dialog box that prompts the visitor for input
    > removeEventListener()	 Removes an event handler from the window
    > requestAnimationFrame()	 Requests the browser to call a function to update an animation before the next repaint
    > resizeBy()	                 Resizes the window by the specified pixels
    > resizeTo()	                 Resizes the window to the specified width and height
    > scrollBy()	                 Scrolls the document by the specified number of pixels
    > scrollTo()	                 Scrolls the document to the specified coordinates
    > stop()	                 Stops the window from loading
     
 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- HTML DOM Documents (Document Object Properties and Methods)
    
    > activeElement	            Returns the currently focused element in the document
    > addEventListener()	      Attaches an event handler to the document
    > adoptNode()	            Adopts a node from another document
    > baseURI	                 Returns the absolute base URI of a document
    > body	                       Sets or returns the document's body (the <body> element)
    > characterSet	            Returns the character encoding for the document
    > close()	                  Closes the output stream previously opened with document.open()
    > cookie	                 Returns all name/value pairs of cookies in the document
    > createAttribute()	        Creates an attribute node
    > createComment()	           Creates a Comment node with the specified text
    > createDocumentFragment()	Creates an empty DocumentFragment node
    > createElement()            Creates an Element node. Se debe indicar el nombre de etiqueta HTML que representará ese elemento. Luego debe agregarse como hijo el nodo Screado con append(), al body o a otro nodo del documento actual.
    > createEvent()	            Creates a new event
    > createTextNode()	       Creates a Text node
    > defaultView	            Returns the window object associated with a document, or null if none is available.
    > designMode	                 Controls whether the entire document should be editable or not.
    > doctype	                Returns the Document Type Declaration associated with the document
    > documentElement	           Returns the Document Element of the document (the <html> element)
    > documentURI	            Sets or returns the location of the document
    > domain	                Returns the domain name of the server that loaded the document
    > embeds	                Returns a collection of all <embed> elements the document
    > forms	                 Returns a collection of all <form> elements in the document
    > getElementById()	       Returns the element that has the ID attribute with the specified value
    > getElementsByClassName()	 Returns an HTMLCollection containing all elements with the specified class name
    > getElementsByName()	      Returns an live NodeList containing all elements with the specified name
    > getElementsByTagName()	Returns an HTMLCollection containing all elements with the specified tag name
    > hasFocus()	                Returns a Boolean value indicating whether the document has focus
    > head	                     Returns the <head> element of the document
    > images	                Returns a collection of all <img> elements in the document
    > implementation	           Returns the DOMImplementation object that handles this document
    > importNode()	            Imports a node from another document
    > lastModified	            Returns the date and time the document was last modified
    > links	                 Returns a collection of all <a> and <area> elements in the document that have a href attribute
    > normalize()	            Removes empty Text nodes, and joins adjacent nodes
    > open()	                Opens an HTML output stream to collect output from document.write()
    > querySelector()	           Returns the first element that matches a specified CSS selector(s) in the document
    > querySelectorAll()	     Returns a static NodeList containing all elements that matches a specified CSS selector(s) in the document
    > readyState	                Returns the (loading) status of the document
    > referrer	                Returns the URL of the document that loaded the current document
    > removeEventListener()	     Removes an event handler from the document (that has been attached with the addEventListener() method)
    > scripts	                Returns a collection of <script> elements in the document
    > title	                 Sets or returns the title of the document
    > URL	                    Returns the full URL of the HTML document
    > write()	                Writes HTML expressions or JavaScript code to a document
    > writeln()	                Same as write(), but adds a newline character after each statement    
  
- HTML DOM elements    

    > accessKey	                Sets or returns the accesskey attribute of an element
    > addEventListener()	     Attaches an event handler to an element
    > append()                  This method is used to add an element in form of a Node object or a DOMString (basically means text).
    > appendChild()	           Adds (appends) a new child node to an element
    > attributes	                Returns a NamedNodeMap of an element's attributes
    > blur()	                Removes focus from an element
    > childElementCount	     Returns an elements's number of child elements
    > childNodes	                Returns a NodeList of an element's child nodes
    > children	                Returns an HTMLCollection of an element's child elements
    > classList	                Returns the class name(s) of an element. It returns the CSS classnames of an element or DOMTokenList.
    > className	                Sets or returns the value of the class attribute of an element. Si asignamos algo a elem.className, reemplaza toda la cadena de clases. A veces es lo que necesitamos, pero a menudo queremos agregar o eliminar 
                                una sola clase. Acceso directo al valor del atributo HTML class. También se puede asignar.
    > click()     	            Simulates a mouse-click on an element
    > clientHeight	            Returns the height of an element, including padding
    > clientLeft	                Returns the width of the left border of an element
    > clientTop	                Returns the width of the top border of an element
    > clientWidth	                Returns the width of an element, including padding
    > cloneNode()	                Clones an element
    > closest()	                Searches the DOM tree for the closest element that matches a CSS selector. This is the opposite to the querySelctor() and also traverses the element and its parents (heading toward the document root) until it 
                                finds a node that matches the specified CSS selector.
    > compareDocumentPosition()	Compares the document position of two elements
    > contains()	                Returns true if a node is a descendant of a node
    > contentEditable	            Sets or returns whether the content of an element is editable or not
    
    > dataset                    This read-only property of the HTMLElement interface provides read/write access to custom data attributes (data-*) on elements. It exposes a map of strings (DOMStringMap) with an entry for each data-*              
                                 attribute. We can have  <div id="user" data-id="1234567890" data-user="carinaanand" data-date-of-birth> and do the following: 
                                 const el = document.querySelector("#user");
                                 el.dataset.dateOfBirth = "1960-10-03";
                                 
    > dir	                        Sets or returns the value of the dir attribute of an element
    > firstChild	                Returns the first child node of an element
    > firstElementChild	        Returns the first child element of an element
    > focus()	                    Gives focus to an element
    > getAttribute()	            Returns the value of an element's attribute
    > getAttributeNode()	        Returns an attribute node
    > getBoundingClientRect()	    Returns the size of an element and its position relative to the viewport
    > getElementsByClassName()	Returns a collection of child elements with a given class name
    > getElementsByTagName()	    Returns a collection of child elements with a given tag name
    > hasAttribute()	            Returns true if an element has a given attribute
    > hasAttributes()	            Returns true if an element has any attributes
    > hasChildNodes()	            Returns true if an element has any child nodes
    > id	                     It's used to set or return the id attribute of an element i.e value of the Id Attribute. An ID should be different in a document. It is returned by using the document.getElementById() method. 
    > innerHTML	                Sets or returns the content of an element. Para borrar el contenido que hay dentro de la etiqueta, usamos lo siguiente (aplica para igual para innerText) con comillas vacias: nombre_variable.innerHTML = "";
    > innerText	                Sets or returns the text content of a node and its descendants. Nos permite modificar su nodo de texto. Es decir, acceder y/o modificar el contenido textual de algún elemento del DOM.
    > insertAdjacentElement()	    Inserts a new HTML element at a position relative to an element
    > insertAdjacentHTML()	    Inserts an HTML formatted text at a position relative to an element
    > insertAdjacentText()	    Inserts text into a position relative to an element
    > insertBefore()	            Inserts a new child node before an existing child node
    > isContentEditable	        Returns true if an element's content is editable
    > isDefaultNamespace()	    Returns true if a given namespaceURI is the default
    > isEqualNode()	            Checks if two elements are equal
    > isSameNode()	            Checks if two elements are the same node
    > lang	                    Sets or returns the value of the lang attribute of an element
    > lastChild	                Returns the last child node of an element
    > lastElementChild	        Returns the last child element of an element
    > matches()	                Returns true if an element is matched by a given CSS selector
    > namespaceURI	            Returns the namespace URI of an element
    > nextSibling	                Returns the next node at the same node tree level
    > nextElementSibling	        Returns the next element at the same node tree level
    > nodeName	                Returns the name of a node
    > nodeType	                Returns the node type of a node
    > nodeValue	                Sets or returns the value of a node
    > normalize()	                Joins adjacent text nodes and removes empty text nodes in an element
    > offsetHeight	            Returns the height of an element, including padding, border and scrollbar
    > offsetWidth	                Returns the width of an element, including padding, border and scrollbar
    > offsetLeft	                Returns the horizontal offset position of an element
    > offsetParent	            Returns the offset container of an element
    > offsetTop	                Returns the vertical offset position of an element
    > outerHTML	                Sets or returns the content of an element (including the start tag and the end tag)
    > outerText	                Sets or returns the outer text content of a node and its descendants
    > ownerDocument	            Returns the root element (document object) for an element
    > parentNode	                Returns the parent node of an element
    > parentElement	            Returns the parent element node of an element
    > previousSibling	            Returns the previous node at the same node tree level
    > prepend()                  Inserts specified content at the beginning of the selected elements.
    > previousElementSibling	    Returns the previous element at the same node tree level
    > querySelector()	            Returns the first child element that matches a CSS selector(s). Nos permite seleccionar nodos con la misma sintaxis que utilizamos en los selectores de CSS
    > querySelectorAll()	        Returns all child elements that matches a CSS selector(s). Permite btener una colección de elementos.
    > remove()	                Removes an element from the DOM
    > removeAttribute()	        Removes an attribute from an element
    > removeAttributeNode()	    Removes an attribute node, and returns the removed node
    > removeChild()	            Removes a child node from an element
    > removeEventListener()	    Removes an event handler that has been attached with the addEventListener() method
    > replaceChild()	            Replaces a child node in an element
    > scrollHeight	            Returns the entire height of an element, including padding
    > scrollIntoView()	        Scrolls the an element into the visible area of the browser window
    > scrollLeft	                Sets or returns the number of pixels an element's content is scrolled horizontally
    > scrollTop	                Sets or returns the number of pixels an element's content is scrolled vertically
    > scrollWidth	                Returns the entire width of an element, including padding
    > setAttribute("tag", "nameTag")	            Sets or changes an attribute's value or sets a new value to an attribute. If the attribute does not exist, it is created first.
    > setAttributeNode()	        Sets or changes an attribute node
    > style	                    Sets or returns the value of the style attribute of an element
    > tabIndex	                Sets or returns the value of the tabindex attribute of an element
    > tagName	                    Returns the tag name of an element
    > textContent	                Sets or returns the textual content of a node and its descendants
    > title	                    Sets or returns the value of the title attribute of an element
    > toString()	                Converts an element to a string    
    
- HTML Event Properties
    > altKey	            Returns whether the "ALT" key was pressed when the mouse event was triggered	MouseEvent
    > altKey	            Returns whether the "ALT" key was pressed when the key event was triggered	    KeyboardEvent, TouchEvent
    > animationName	        Returns the name of the animation	                                            AnimationEvent
    > bubbles	            Returns whether or not a specific event is a bubbling event	                     Event
    > button	            Returns which mouse button was pressed when the mouse event was triggered	     MouseEvent
    > buttons	            Returns which mouse buttons were pressed when the mouse event was triggered	    MouseEvent
    > cancelable	        Returns whether or not an event can have its default action prevented	Event
    > changeTouches	        Returns a list of all the touch objects whose state changed between the previous touch and this touch	TouchEvent
    > clientX	            Returns the horizontal coordinate of the mouse pointer, relative to the current window, when the mouse event was triggered	MouseEvent, TouchEvent
    > clientY	            Returns the vertical coordinate of the mouse pointer, relative to the current window, when the mouse event was triggered	MouseEvent, TouchEvent
    > clipboardData	        Returns an object containing the data affected by the clipboard operation	ClipboardData
    > code	                Returns the code of the key that triggered the event	KeyboardEvent
    > composed	            Returns whether the event is composed or not	Event
    > ctrlKey	            Returns whether the "CTRL" key was pressed when the mouse event was triggered	MouseEvent
    > ctrlKey	            Returns whether the "CTRL" key was pressed when the key event was triggered	KeyboardEvent, TouchEvent
    > currentTarget	        Returns the element whose event listeners triggered the event. It is the element that the event listener is attached to.	(currentTarget is similar to the "this" keyword)         Event
    > data	                Returns the inserted characters	InputEvent
    > dataTransfer	        Returns an object containing the data being dragged/dropped, or inserted/deleted	DragEvent, InputEvent
    > defaultPrevented	    Returns whether or not the preventDefault() method was called for the event	Event
    > deltaX	            Returns the horizontal scroll amount of a mouse wheel (x-axis)	WheelEvent
    > deltaY	            Returns the vertical scroll amount of a mouse wheel (y-axis)	WheelEvent
    > deltaZ	            Returns the scroll amount of a mouse wheel for the z-axis	WheelEvent
    > deltaMode	            Returns a number that represents the unit of measurements for delta values (pixels, lines or pages)	WheelEvent
    > detail	            Returns a number that indicates how many times the mouse was clicked	UiEvent
    > elapsedTime	        Returns the number of seconds an animation has been running	AnimationEvent
    > elapsedTime	        Returns the number of seconds a transition has been running	 
    > eventPhase	        Returns which phase of the event flow is currently being evaluated	Event
    > getModifierState()	Returns an array containing target ranges that will be affected by the insertion/deletion	MouseEvent
    > inputType	            Returns the type of the change (i.e "inserting" or "deleting")	InputEvent
    > isComposing	        Returns whether the state of the event is composing or not	InputEvent, KeyboardEvent
    > isTrusted	            Returns whether or not an event is trusted	Event
    > key	                Returns the key value of the key represented by the event	KeyboardEvent
    > key	                Returns the key of the changed storage item	Storage         Event
    > location	            Returns the location of a key on the keyboard or device	KeyboardEvent
    > lengthComputable	    Returns whether the length of the progress can be computable or not	ProgressEvent
    > loaded	            Returns how much work has been loaded	ProgressEvent
    > metaKey	            Returns whether the "META" key was pressed when an event was triggered	MouseEvent
    > metaKey	            Returns whether the "meta" key was pressed when the key event was triggered	KeyboardEvent, TouchEvent
    > MovementX	            Returns the horizontal coordinate of the mouse pointer relative to the position of the last mousemove event	MouseEvent
    > MovementY	            Returns the vertical coordinate of the mouse pointer relative to the position of the last mousemove event	MouseEvent
    > newValue	            Returns the new value of the changed storage item	StorageEvent
    > newURL	            Returns the URL of the document, after the hash has been changed	HasChangeEvent
    > offsetX	            Returns the horizontal coordinate of the mouse pointer relative to the position of the edge of the target element	MouseEvent
    > offsetY	            Returns the vertical coordinate of the mouse pointer relative to the position of the edge of the target element	MouseEvent
    > oldValue	            Returns the old value of the changed storage item	StorageEvent
    > oldURL	            Returns the URL of the document, before the hash was changed	HasChangeEvent
    > onemptied	            When something bad happens and the media file is suddenly unavailable (like unexpectedly disconnects)	 
    > pageX	                Returns the horizontal coordinate of the mouse pointer, relative to the document, when the mouse event was triggered	MouseEvent
    > pageY	                Returns the vertical coordinate of the mouse pointer, relative to the document, when the mouse event was triggered	MouseEvent
    > persisted	            Returns whether the webpage was cached by the browser	PageTransitionEvent
    > propertyName	        Returns the name of the CSS property associated with the animation or transition	AnimationEvent, TransitionEvent
    > pseudoElement	        Returns the name of the pseudo-element of the animation or transition	AnimationEvent, TransitionEvent
    > region		        MouseEvent
    > relatedTarget	        Returns the element related to the element that triggered the mouse event	MouseEvent
    > relatedTarget	        Returns the element related to the element that triggered the event	FocusEvent
    > repeat	            Returns whether a key is being hold down repeatedly, or not	KeyboardEvent
    > screenX	            Returns the horizontal coordinate of the mouse pointer, relative to the screen, when an event was triggered	MouseEvent
    > screenY	            Returns the vertical coordinate of the mouse pointer, relative to the screen, when an event was triggered	MouseEvent
    > shiftKey	            Returns whether the "SHIFT" key was pressed when an event was triggered	MouseEvent
    > shiftKey	            Returns whether the "SHIFT" key was pressed when the key event was triggered	KeyboardEvent, TouchEvent
    > state	                Returns an object containing a copy of the history entries	PopStateEvent
    > storageArea	        Returns an object representing the affected storage object	StorageEvent
    > target	            Returns the element that triggered the event. It is essentially where the event is originated. So where the event first happened.	Event
    > targetTouches	        Returns a list of all the touch objects that are in contact with the surface and where the touchstart event occured on the same target element as the current target element	TouchEvent
    > timeStamp	            Returns the time (in milliseconds relative to the epoch) at which the event was created	Event
    > total	                Returns the total amount of work that will be loaded	ProgressEvent
    > touches	            Returns a list of all the touch objects that are currently in contact with the surface	TouchEvent
    > transitionend	        A CSS transition has completed	TransitionEvent
    > type	                Returns the name of the event	Event
    > url	                Returns the URL of the changed item's document	StorageEvent
    > view	                Returns a reference to the Window object where the event occurred	UiEvent
    > x	                    Alias for clientX	MouseEvent
    > y	                    Alias for clientY    
    
- HTML DOM events
    > abort	                  The loading of a media is aborted	UiEvent, Event
    > afterprint	          A page has started printing	Event
    > animationend	          A CSS animation has completed	AnimationEvent
    > animationiteration	  A CSS animation is repeated	AnimationEvent
    > animationstart	      A CSS animation has started	AnimationEvent
    > beforeprint	          A page is about to be printed	Event
    > beforeunload	          Before a document is about to be unloaded. the user is leaving the page. we can check if the user saved the changes and ask them whether they really want to leave.       UiEvent, Event
    > blur	                  An element loses focus	FocusEvent
    > canplay	              The browser can start playing a media (has buffered enough to begin)	Event
    > canplaythrough	      The browser can play through a media without stopping for buffering	Event
    > change	              The content of a form element has changed	Event
    > click	                  An element is clicked on	MouseEvent
    > contextmenu	          An element is right-clicked to open a context menu	MouseEvent
    > copy	                  The content of an element is copied	ClipboardEvent
    > cut	                  The content of an element is cutted	ClipboardEvent
    > dblclick	              An element is double-clicked	MouseEvent
    
    > DOMContentLoaded:  The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. 
      the browser fully loaded HTML, and the DOM tree is built, but external resources like pictures <img> and stylesheets may not yet have loaded. DOM is ready, so the handler can lookup DOM nodes, initialize the interface. 
      DOM is ready, so the handler can lookup DOM nodes, initialize the interface.    
      
    > drag	                  An element is being dragged	DragEvent
    > dragend	              Dragging of an element has ended	DragEvent
    > dragenter	              A dragged element enters the drop target	DragEvent
    > dragleave	              A dragged element leaves the drop target	DragEvent
    > dragover	              A dragged element is over the drop target	DragEvent
    > dragstart	              Dragging of an element has started	DragEvent
    > drop	                  A dragged element is dropped on the target	DragEvent
    > durationchange	      The duration of a media is changed	Event
    > ended	                  A media has reach the end ("thanks for listening")	Event
    > error	                  An error has occurred while loading a file	ProgressEvent, UiEvent, Event
    > focus	                  An element gets focus	FocusEvent
    > focusin	              An element is about to get focus	FocusEvent
    > focusout	              An element is about to lose focus	FocusEvent
    > fullscreenchange	      An element is displayed in fullscreen mode	Event
    > fullscreenerror	      An element can not be displayed in fullscreen mode	Event
    > hashchange	          There has been changes to the anchor part of a URL	HashChangeEvent
    > input	                  An element gets user input	InputEvent, Event
    > invalid	              An element is invalid	Event
    > keydown	              A key is down	KeyboardEvent
    > keypress	              A key is pressed	KeyboardEvent
    > keyup	                  A key is released	KeyboardEvent
    > load	                An object has loaded. This event is fired when the whole webpage (HTML) has loaded fully, including all dependent resources, including JavaScript files, CSS files, and images.	         UiEvent, Event
                           not only HTML is loaded, but also all the external resources: images, styles etc. External resources are loaded, so styles are applied, image sizes are known etc.
    > loadeddata	          Media data is loaded	Event
    > loadedmetadata	      Meta data (like dimensions and duration) are loaded	Event
    > loadstart	              The browser starts looking for the specified media	ProgressEvent
    > message	              A message is received through the event source	Event
    > mousedown	              The mouse button is pressed over an element	MouseEvent
    > mouseenter	          The pointer is moved onto an element	MouseEvent
    > mouseleave	          The pointer is moved out of an element	MouseEvent
    > mousemove	              The pointer is moved over an element	MouseEvent
    > mouseover	              The pointer is moved onto an element	MouseEvent
    > mouseout	              The pointer is moved out of an element	MouseEvent
    > mouseup	              A user releases a mouse button over an element	MouseEvent
    > offline	              The browser starts working offline	Event
    > online	              The browser starts working online	Event
    > open	                  A connection with the event source is opened	Event
    > pagehide	              User navigates away from a webpage	PageTransitionEvent
    > pageshow	              User navigates to a webpage	PageTransitionEvent
    > paste	                  Some content is pasted in an element	ClipboardEvent
    > pause	                  A media is paused	Event
    > play	                  The media has started or is no longer paused	Event
    > playing	              The media is playing after beeing paused or buffered	Event
    > popstate	              The window's history changes	PopStateEvent
    > progress	              The browser is downloading media data	Event
    > ratechange	          The playing speed of a media is changed	Event
    > resize	              The document view is resized	UiEvent, Event
    > reset	                  A form is reset	Event
    > scroll	              An scrollbar is being scrolled	UiEvent, Event
    > search	              Something is written in a search field	Event
    > seeked	              Skipping to a media position is finished	Event
    > seeking	              Skipping to a media position is started	Event
    > select	              User selects some text	UiEvent, Event
    > show	                  A <menu> element is shown as a context menu	Event
    > stalled	              The browser is trying to get unavailable media data	Event
    > storage	              A Web Storage area is updated	StorageEvent
    > submit	              A form is submitted	Event
    > suspend	              The browser is intentionally not getting media data	Event
    > timeupdate	          The playing position has changed (the user moves to a different point in the media)	Event
    > toggle	              The user opens or closes the <details> element	Event
    > touchcancel	          The touch is interrupted	TouchEvent
    > touchend	              A finger is removed from a touch screen	TouchEvent
    > touchmove	              A finger is dragged across the screen	TouchEvent
    > touchstart	          A finger is placed on a touch screen	TouchEvent
    > transitionend	          A CSS transition has completed	TransitionEvent
    > unload	              A page has unloaded. the user is leaving the page. the user almost left, but we still can initiate some operations, such as sending out statistics.    	UiEvent, Event
    > volumechange	          The volume of a media is changed (includes muting)	Event
    > waiting	              A media is paused but is expected to resume (e.g. buffering)	Event
    > wheel	                  The mouse wheel rolls up or down over an element	WheelEvent    
    
- addEventListener DOM Event Types
    > Mouse Events:    click, dblclick, mousedown, mouseup, contextmenu, mouseout, mousewheel, mouseover
    > Touch Events:    touchstart, touchend, touchmove, touchcancel
    > Keyboard Events: keydown, keyup, keypress
    > Form Events:     focus, blur, change, submit, input
    > Window Events:   resize, scroll, load, unload, hashchange    
           
- Finding HTML Elements
    > document.getElementById(id)	        Find an element by element id
    > document.getElementsByTagName(name)	   Find elements by tag name
    > document.getElementsByClassName(name)	Find elements by class name

- Changing HTML Elements
    > element.innerHTML =  new html content	Change the inner HTML of an element
    > element.attribute = new value	        Change the attribute value of an HTML element
    > element.style.property = new style	    Change the style of an HTML element
    > element.setAttribute(attribute, value)	Change the attribute value of an HTML element

- Adding and Deleting Elements
    > document.createElement(element)	   Create an HTML element
    > document.removeChild(element)	   Remove an HTML element
    > document.appendChild(element)	   Add an HTML element
    > document.replaceChild(new, old)	   Replace an HTML element
    > document.write(text)	           Write into the HTML output stream
    
- Attribute Properties
    > name	      Returns an attribute's name
    > value	Sets or returns an attribute's value. Para obtener o modificar datos de un formulario HTML desde JS, podemos hacerlo mediante el DOM. Accediendo a la propiedad value de cada input seleccionado.
    > specified	Returns true if the attribute is specified
    
- NamedNodeMap Properties and Methods
    > getNamedItem()	      Returns an attribute node (by name) from a NamedNodeMap
    > item()	           Returns an attribute node (by index) from a NamedNodeMap
    > length	           Returns the number of attributes in a NamedNodeMap
    > removeNamedItem()	Removes an attribute (node)
    > setNamedItem()	     Sets an attribute (node) by name  
    > namedItem()	     Returns the element with a specified id

- HTML DOM NodeList
    > entries()	Returns an Iterator with the key/value pairs from the list
    > forEach()	Executes a callback function for each node in the list
    > item()	Returns the node at a specified index
    > keys()	Returns an Iterator with the keys from the list
    > length	Returns the number of nodes in a NodeList
    > values()	Returns an Iterator with the values from the list
    
- HTML DOM Event Methods

    > getModifierState()	          Returns true if a specified key is activated MouseEvent
    > getTargetRanges()	          Returns an array containing target ranges that will be affected by the insertion/deletion InputEvent
    > preventDefault()	          Cancels the event if it is cancelable, meaning that the default action that belongs to the event will not occur Event
    > stopImmediatePropagation()	     Prevents other listeners of the same event from being called Event
    > stopPropagation()	          Prevents further propagation of an event during event flow    
         
- Adding Events Handlers
    > document.getElementById(id).onclick = function(){code}	Adding event handler code to an onclick event

- Finding HTML Objects
    > document.anchors	            Returns all <a> elements that have a name attribute
    > document.baseURI	            Returns the absolute base URI of the document
    > document.body	                Returns the <body> element
    > document.cookie	                Returns the document's cookie
    > document.doctype	            Returns the document's doctype
    > document.documentElement	    Returns the <html> element
    > document.documentMode	        Returns the mode used by the browser
    > document.documentURI	        Returns the URI of the document
    > document.domain	                Returns the domain name of the document server
    > document.embeds	                Returns all <embed> elements
    > document.forms	                Returns all <form> elements
    > document.head	                Returns the <head> element
    > document.images	                Returns all <img> elements
    > document.implementation	        Returns the DOM implementation
    > document.inputEncoding	        Returns the document's encoding (character set)
    > document.lastModified	        Returns the date and time the document was updated
    > document.links	                Returns all <area> and <a> elements that have a href attribute
    > document.readyState	            Returns the (loading) status of the document
    > document.referrer	            Returns the URI of the referrer (the linking document)
    > document.scripts	            Returns all <script> elements
    > document.strictErrorChecking	Returns if error checking is enforced
    > document.title	                Returns the <title> element
    > document.URL	                Returns the complete URL of the document    
    
- classList Properties and Methods

    > add()   	Adds one or more tokens to the list. Adds an option to a drop-down list
    > contains()	Returns true if the list contains a class
    > entries()	Returns an Iterator with key/value pairs from the list
    > forEach()	Executes a callback function for each token in the list
    > item()	Returns the token at a specified index
    > keys()	Returns an Iterator with the keys in the list
    > length	Returns the number of tokens in the list
    > remove()	Removes one or more tokens from the list. Removes an option from a drop-down list
    > replace()	Replaces a token in the list
    > supports()	Returns true if a token is one of an attribute's supported tokens
    > toggle()	Toggles between tokens in the list. It removes an existing token from the list and returns false. If the token doesn't exist it's added and the function returns true. 
                Permite cada vez que se ejecute cambiar de estado la visibilidad del elemento HTML, es decir si está visible pasa a oculto y si se encuentra oculto pasa a visible.
    > value      Returns the token list as a string
    > values()	Returns an Iterator with the values in the list   
    
- HTML DOM Image Object
    > align	      Use style.cssFloat instead. Sets or returns the value of the align attribute of an image
    > alt	          Sets or returns the value of the alt attribute of an image
    > border	     Use style.border instead. Sets or returns the value of the border attribute of an image
    > complete	     Returns whether or not the browser is finished loading an image
    > crossOrigin	 Sets or returns the CORS settings of an image
    > height	     Sets or returns the value of the height attribute of an image
    > hspace	     Use style.margin instead. Sets or returns the value of the hspace attribute of an image
    > isMap	         Sets or returns whether an image should be part of a server-side image-map, or not
    > longDesc	     Sets or returns the value of the longdesc attribute of an image
    > lowsrc	     Sets or returns a URL to a low-resolution version of an image
    > name	            Use id instead. Sets or returns the value of the name attribute of an image
    > naturalHeight	 Returns the original height of an image
    > naturalWidth	 Returns the original width of an image
    > src	           Sets or returns the value of the src attribute of an image
    > useMap	     Sets or returns the value of the usemap attribute of an image
    > vspace	     Use style.margin instead. Sets or returns the value of the vspace attribute of an image
    > width	         Sets or returns the value of the width attribute of an image
    
- onclick events
    > onclick	     The user clicks on an element
    > oncontextmenu	The user right-clicks on an element
    > ondblclick	      The user double-clicks on an element
    > onmousedown	A mouse button is pressed over an element
    > onmouseenter	The pointer is moved onto an element
    > onmouseleave	The pointer is moved out of an element
    > onmousemove	The pointer is moving over an element
    > onmouseout	     The mouse pointer moves out of an element
    > onmouseover	The mouse pointer is moved over an element
    > onmouseup	      The mouse button is released over an element   
    
- Input Search Object Properties
    > autocomplete	  Sets or returns the value of the autocomplete attribute of a search field
    > autofocus	      Sets or returns whether a search field should automatically get focus when the page loads
    > defaultValue	  Sets or returns the default value of a search field
    > disabled	      Sets or returns whether a search field is disabled, or not
    > form	          Returns a reference to the form that contains the search field
    > list	          Returns a reference to the datalist that contains the search field
    > maxLength	      Sets or returns the value of the maxlength attribute of a search field
    > name	          Sets or returns the value of the name attribute of a search field
    > pattern	      Sets or returns the value of the pattern attribute of a search field
    > placeholder	  Sets or returns the value of the placeholder attribute of a search field
    > readOnly	      Sets or returns whether the search field is read-only, or not
    > required	      Sets or returns whether the search field must be filled out before submitting a form
    > size	          Sets or returns the value of the size attribute of the search field
    > type	          Returns which type of form element the search field is
    > value	    Sets or returns the value of the value attribute of a search field. Para obtener o modificar datos de un formulario HTML desde JS, podemos hacerlo mediante el DOM. Accediendo a la propiedad value de cada input deseado.

- Input Search Object Methods
    > Method	Description
    > blur()	Removes focus from a search field
    > focus()	Gives focus to a search field
    > select()	Selects the content of a search text field
    
- DOM node types               
    ~ Document:                   Nodo raíz del que derivan todos los demás nodos del  árbol.
    ~ Element:                       Representa cada una de las etiquetas XHTML. Puede contener atributos y derivar otros nodos de él.
    ~ Attr:                    Se define un nodo de este tipo para representar cada uno de los atributos de las etiquetas HTML, es decir, uno por cada par atributo=valor.
    ~ Text:                     Nodo que contiene el texto encerrado por una etiqueta  HTML.
    ~ Comment:                   Representa los comentarios incluidos en la página HTML.                
    > Document	                 Represents the entire document (the root-node of the DOM tree)	                          Element (max. one), ProcessingInstruction, Comment, DocumentType
    > DocumentFragment	         Represents a "lightweight" Document object, which can hold a portion of a document	     Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference
    > DocumentType	             Provides an interface to the entities defined for the document	                           None
    > ProcessingInstruction	     Represents a processing instruction	                                                 None
    > EntityReference	         Represents an entity reference	                                                            Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference
    > Element	                 Represents an element	                                                                 Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference
    > Attr	                     Represents an attribute	                                                                Text, EntityReference
    > Text	                     Represents textual content in an element or attribute	                                      None
    > CDATASection	             Represents a CDATA section in a document (text that will NOT be parsed by a parser)	      None
    > Comment	                 Represents a comment	                                                                      None
    > Entity	                 Represents an entity	                                                                      Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference
    > Notation	                 Represents a notation declared in the DTD	                                                 None
    
- Console Object Methods

    > assert()	         Writes an error message to the console if a assertion is false
    > clear()	             Clears the console
    > count()	             Logs the number of times that this particular call to count() has been called
    > error()              Outputs an error message to the console
    > group()	             Creates a new inline group in the console. This indents following console messages by an additional level, until console.groupEnd() is called
    > groupCollapsed()	 Creates a new inline group in the console. However, the new group is created collapsed. The user will need to use the disclosure button to expand it
    > groupEnd()	         Exits the current inline group in the console
    > info()	             Outputs an informational message to the console
    > log()	             Outputs a message to the console
    > table()	             Displays tabular data as a table
    > time()	             Starts a timer (can track how long an operation takes)
    > timeEnd()	         Stops a timer that was previously started by console.time()
    > trace()	             Outputs a stack trace to the console
    > warn()	             Outputs a warning message to the console    
    
    
- Window Object properties and Methods
    > closed	      Returns a boolean true if a window is closed.
    > console	      Returns the Console Object for the window.
    > document	      Returns the Document object for the window.
    > frameElement	  Returns the frame in which the window runs.
    > frames	      Returns all window objects running in the window.
    > history	      Returns the History object for the window.
    > innerHeight	  Returns the height of the window's content area (viewport) including scrollbars
    > innerWidth	  Returns the width of a window's content area (viewport) including scrollbars
    > length	      Returns the number of <iframe> elements in the current window
    > localStorage	  Allows to save key/value pairs in a web browser. Stores the data with no expiration date
    > location	      Returns the Location object for the window.
    > name	          Sets or returns the name of a window
    > navigator	      Returns the Navigator object for the window.
    > opener	      Returns a reference to the window that created the window
    > outerHeight	  Returns the height of the browser window, including toolbars/scrollbars
    > outerWidth	  Returns the width of the browser window, including toolbars/scrollbars
    > pageXOffset	  Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
    > pageYOffset	  Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
    > parent	      Returns the parent window of the current window
    > screen	      Returns the Screen object for the window
    > screenLeft	  Returns the horizontal coordinate of the window relative to the screen
    > screenTop	      Returns the vertical coordinate of the window relative to the screen
    > screenX	      Returns the horizontal coordinate of the window relative to the screen
    > screenY	      Returns the vertical coordinate of the window relative to the screen
    > sessionStorage  Allows to save key/value pairs in a web browser. Stores the data for one session
    > scrollX	      An alias of pageXOffset
    > scrollY	      An alias of pageYOffset
    > self	          Returns the current window
    > top	          Returns the topmost browser window
    
    > addEventListener()	      Attaches an event handler to the window
    > alert()	                  Displays an alert box with a message and an OK button
    > atob()	                  Decodes a base-64 encoded string
    > blur()	                  Removes focus from the current window
    > btoa()	                  Encodes a string in base-64
    > clearInterval()	          Clears a timer set with setInterval()
    > clearTimeout()	          Clears a timer set with setTimeout()
    > close()	                  Closes the current window
    > confirm()	                  Displays a dialog box with a message and an OK and a Cancel button
    > focus()	                  Sets focus to the current window
    > getComputedStyle()	      Gets the current computed CSS styles applied to an element
    > getSelection()	          Returns a Selection object representing the range of text selected by the user
    > matchMedia()	              Returns a MediaQueryList object representing the specified CSS media query string
    > moveBy()	                  Moves a window relative to its current position
    > moveTo()	                  Moves a window to the specified position
    > open()	                  Opens a new browser window
    > print()	                  Prints the content of the current window
    > prompt()	                  Displays a dialog box that prompts the visitor for input
    > removeEventListener()	      Removes an event handler from the window
    > requestAnimationFrame()	  Requests the browser to call a function to update an animation before the next repaint
    > resizeBy()	              Resizes the window by the specified pixels
    > resizeTo()	              Resizes the window to the specified width and height
    > scrollBy()	              Scrolls the document by the specified number of pixels
    > scrollTo()	              Scrolls the document to the specified coordinates
    > setInterval()	              Calls a function or evaluates an expression at specified intervals (in milliseconds)
    > setTimeout()	              Calls a function or evaluates an expression after a specified number of milliseconds
    > stop()	                  Stops the window from loading       
    
    
- Difference between window, screen and document: 
  ~ window. It is the main JavaScript object root, the global object in a browser, and it can also be treated as the root of the document object model. It is the first thing that gets loaded into the browser. This window object has the 
    majority of the properties like length, innerWidth, innerHeight, name, if it has been closed, its parents, and more.
  
  ~ document: It is the main object of the potentially visible (or better yet: rendered) document object model/DOM. The document object is your html, aspx, php, or other document that will be loaded into the browser. The document actually 
    gets loaded inside the window object and has properties available to it like title, URL, cookie, etc. What does this really mean? That means if you want to access a property for the window it is window.property, if it 
    is document it is window.document.property which is also available in short as document.property.
  
  Since window is the global object, you can reference any properties of it with just the property name - so you do not have to write down window. - it will be figured out by the runtime.
        
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
    
- Operadores logicos avanzados

Operador ternario ?:  	               a ? b : c	                Si a es true, devuelve b, sino devuelve c.
Operador unario lógico NOT	               !a	   
Operador de asignación lógica nula ??=    a ??= b	                Es equivalente a   a ?? (a = b)

Operador lógico AND                       a && b	                     Devuelve a si es false, sino devuelve b.
Operador lógico OR                        a || b	                     Devuelve a si es true, sino devuelve b.
Operador lógico Nullish coalescing        a ?? b	                     Devuelve b si a es null o undefined, sino devuelve a.  funciona igual que el Operador OR ( || ), con la diferencia que admite más valores como ‘verdaderos’.
Operador de encadenamiento opcional ?.    data?.name                 Permite intentar acceder a una propiedad, aunque su padre no exista. Si intentamos acceder a un objeto que no existe naturalmente obtendremos un error en consola. Pero, si 
                                                                     usamos el operador ?. sobre la referencia de un objeto para condicionar su acceso podemos tener un mejor control de errores en la ejecución. En este caso, en caso de que 
                                                                     algo no exista, en lugar de tirar un error en consola, obtendremos un undefinded
                                                                     
  > Desestructuración Es decir, los nombres de las variables deben coincidir exactamente con los nombres de las propiedades que queremos obtener del objeto. En el ejemplo anterior, podemos desestructurar el objeto de la siguiente forma:
  
    const usuario = {nombre: "John Doe", edad: 32}
    const { nombre, edad } = usuario
    console.log(nombre) // "John Doe"
    console.log(edad) // 32
    
    Si intentamos desestructurar una propiedad inexistente en el objeto, obtendremos undefined. Cada propiedad que queramos desestructurar del objeto las declaramos separadas por comas. Recordemos que en este caso y en los anteriores, 
    estamos declarando variables con los nombres nombre, edad, y teléfono; por lo que luego las referenciamos con este nombre.
    Si queremos acceder a propiedades más internas dentro de un objeto, es decir desestructurar alguna propiedad que sea a la vez un objeto, es posible hacerlo siguiendo el mismo patrón. 
    En este caso, como teléfono es un objeto, desestructuramos la propiedad trabajo de éste, dentro de la desestructuración de usuario. Nótese que finalmente se terminan declarando dos variables, nombre y trabajo. 
    Recordar que siempre se deben utilizar las mismas variables cuando desestructuramos un objeto, pero en un array SI se pueden cambiar.
    
    const usuario = { nombre: "John Doe", edad: 32, telefono: {cel: 113334444, casa: null, trabajo: 113325555} }
    const { nombre, telefono: {trabajo} } = usuario; 
    console.log(nombre); // "John Doe"
    console.log(trabajo); // 113325555
    
  > Alias: Para que la desestructuración funcione debe haber coincidencia con los nombres de las propiedades del objeto.
    Sin embargo a veces puede que los nombres de las propiedades no sean muy descriptivos para el uso que queremos darle, y por ello podemos desestructurarlas con un alias, es decir declarar la variable con un nombre alternativo tras haber 
    desestructurado el objeto. Esto lo hacemos simplemente con el operador : luego del nombre de la propiedad. En este caso desestructuramos todas las propiedades de item, pero lo almacenamos en variables denominadas id, nombre, precio, a 
    través del alias que indicamos para cada una.
    
    const item = {item_id: 432, product_name: "Some product", price_per_unit: 5600}
    const {item_id: id, product_name: nombre, price_per_unit: precio} = item
    console.log(id) // 432
    console.log(nombre) // "Some product"
    console.log(precio) // 5600
    
  > Desestructuración en parámetros: Si en una función recibimos objetos por parámetros, también es posible desestructurarlos directamente en el llamado, definiendo esto al declarar la función. Por ejemplo, supongamos una función que recibe 
    un objeto producto por parámetro y debe trabajar con sus propiedades id y nombre
    
  > Desestructuración de arrays: Es posible desestructurar arrays de forma similar, usando corchetes [] en vez de llaves. La diferencia con la desestructuración de objetos es que la de arrays es posicional. Es decir, declaramos las 
    variables en orden y estas almacenan los valores de las mismas posiciones del array de referencia:   
    No funciona aquí la coincidencia por nombres, sino que se toman los valores según la posición. Las dos primeras variables que declaramos tomarán los valores de los dos primeros elementos del array. Si queremos acceder a otras 
    posiciones, o mejor dicho omitir las primeras, podemos hacerlo dejando espacios vacíos con comas:
    
  > Operador Spread: Spread (...) es una herramienta que nos permite, como su nombre indica, desparramar un array u objeto. En otras palabras, cambiar la forma en la que presentamos este array u objeto. Esta se puede utilizar para crear 
    copias de un objeto o array sin necesidad de alterar o modificar los valores principales de esos elementos. Se le conoce como copia por valor. 
     
  > Spread de arrays: Lo que hace el spread (...) al aplicarse sobre un array, es enviar todos sus elementos como parámetros individuales. Esto es útil cuando tenemos datos ordenados dentro de una colección pero trabajamos con funciones 
    que no funcionan recibiendo arrays sino una serie de parámetros individuales, como pueden ser Math.max() o Math.min(). Con spread podemos solucionar esto ya que Math.max() recibirá cada elemento del array como un parámetro individual:
    También podemos hacer spread de un array dentro de otras estructuras que lo admitan. Esto nos permite, por ejemplo, replicar el contenido de un array dentro de otra estructura al desparramar su contenido dentro. 
    Si lo hacemos dentro de un objeto veremos algo interesante, que cada propiedad toma como nombre el índice de los elementos.
         
  > Spread de objetos:  Se puede hacer spread de objetos también, pero debe hacerse dentro de una estructura que lo permita, como otro objeto.
    Un spread aplicado sobre un objeto presentaría cada par de clave-valor separado por comas, y ésto en una función no sería admisible, pero sí puede serlo dentro de otro objeto.
    Esto suele ser útil cuando queremos replicar o modificar estructuras de objetos, ya que nos permite primero listar todas sus propiedades y valores y luego modificar/agregar las que queramos.
       
  > Rest parameters El operador spread también puede utilizarse dentro de la declaración de una función para indicar que queremos recibir una cantidad indeterminada de parámetros. Supongamos que quiero tener una función para sumar 
    cualquier cantidad de números ue reciba por parámetro. Puedo hacer esto con el operador spread definiendo rest parameters, lo que significa que mi función va a recibir una cantidad indeterminada de parámetros, pero los va a agrupar 
    dentro de un array con el nombre que defina, y con eso trabajará dentro.
    

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        


                                                                                                                   Almacenamiento de archivos


- Storage API: The Storage object of the Web Storage API provides access to the session storage or local storage for a particular domain. This allows you to read, add, modify, and delete stored data items.
   > localStorage:   The localStorage object stores the data with no expiration date. The data will not be deleted when the browser is closed, and will be available the next day, week, or year.
   > sessionStorage: The sessionStorage object is equal to the localStorage object, except that it stores the data for only one session. The data is deleted when the user closes the specific browser tab.
   > getItem()	     Returns the value of the specified key name. Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > setItem()	     Adds a key to the storage, or updates a key's value if it already exists. Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren 
                     los datos de navegación del browser). La información persiste reinicio de navegador y hasta del sistema operativo. Solo existe dentro de la pestaña actual del navegador. Otra pestaña con la misma página tendrá otro 
                     sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen)
   > clear()	     Empty all key out of the storage
   > key(            Returns the name of the nth key in the storage. Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle for convencional unicamente y colocando localStorage.key(i);
   > length	     Returns the number of data items stored in the Storage object
   > removeItem()    Removes a key from the storage    
    
- JSON: It is a format for storing and transporting data. JSON is text, and text can be transported anywhere, and read by any programming language.   
   > JSON.parse();          Parses a JSON string and returns a JavaScript object. Recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript.
   > JSON.stringify();      Convert a JavaScript object to a JSON string. acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON. 
   
- fs en Nodejs: fs es la abreviación utilizada para FileSystem, el cual, como indica el nombre, es un sistema de manejador de archivos que nos proporcionará node para poder crear, leer, actualizar o eliminar un archivo, sin tener que hacerlo 
     nosotros desde cero. Así, crear un archivo con contenido será tan fácil como escribir un par de líneas de código, en lugar de tener que lidiar con los datos binarios y transformaciones complejas y de un nivel más bajo en la computadora.
     fs existe desde el momento en el que instalamos Nodejs en nuestro computador, por lo que, para utilizarlo, podemos llamarlo desde cualquier archivo que tengamos de nuestro código con la siguiente línea:
                                                                                   
                                                                                   const = fs = require("fs");
                                                                                   
     De ahí en adelante todo el módulo de FileSystem estará contenido en la variable fs. Sólo debemos utilizarlo llamando sus métodos como una clase. Esto podremos hacerlo de 3 formas: síncrono, con callbacks o con promesas.                                                                                   
     Para utilzar de forma adecuada el fs, sólo utilizaremos la palabra Sync después de cada operación que queramos realizar. Las principales operaciones que podemos hacer con fs síncrono son:
       ✓ writeFileSync = Para escribir contenido en un archivo. Si el archivo no existe, lo crea. Si existe, lo sobreescribe.
       ✓ readFileSync = Para obtener el contenido de un archivo.
       ✓ appendFileSync = Para añadir contenido a un archivo. ¡No se sobreescribe!
       ✓ unlinkSync = Es el “delete” de los archivos. eliminará todo el archivo, no sólo el contenido.
       ✓ existsSync = Corrobora que un archivo exista!
       
- fs con callbacks: Funciona muy similar a las operaciones síncronas. Sólo que al final recibirán un último argumento, que como podemos intuir, debe ser un callback. Según lo vimos en las convenciones de callbacks de la clase pasada, el 
    primer argumento suele ser un error. Esto permite saber si la operación salió bien, o si salió mal. Sólo readFile maneja un segundo argumento, con el resultado de la lectura del archivo.
    Por último: el manejo por callbacks es totalmente asíncrono, así que cuidado dónde lo usas. Las principales operaciones que podemos hacer con fs con callbacks son:
      ✓ writeFile = Para escribir contenido en un archivo. Si el archivo no existe, lo crea. Si existe, lo sobreescribe. Al sólo escribir, su callback sólo maneja: (error)=>
      ✓ readFile = Para obtener el contenido de un archivo. Como pide información, su callback es de la forma: (error, resultado)=>
      ✓ appendFile = Para añadir contenido a un archivo. ¡No se sobreescribe!, al sólo ser escritura, su callback sólo maneja: (error)=>
      ✓ unlink = Es el “delete” de los archivos. eliminará todo el archivo, no sólo el contenido. Al no retornar contenido, su callback sólo es (error)=>
      
     Si queremos utilizar promesas, entonces qudarian como:
      ✓ fs.promises.writeFile
      ✓ fs.promises.readFil
      ✓ fs.promises.appendFile
      ✓ fs.promises.unlink    


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        


                                                                                                                   Asincronia
                                                                                                                   
    > setInterval()              Calls a function or evaluates an expression at specified intervals (in milliseconds).
                                 setInterval funciona como setTimeout, la diferencia radica en que éste reiniciará el conteo y ejecutará la tarea nuevamente cada vez que se cumpla dicho intervalo de tiempo. Un timer devuelve un apagador el 
                                 cual permite detener el intervalo cuando se cumpla cierta operación. Suele utilizarse mucho para poner tiempos límites en alguna página para llenar formularios (Hay ciertas páginas que te dan tiempo límite 
                                 para hacer la operación, O TE BOTAN).
    > setTimeout()               Calls a function or evaluates an expression after a specified number of milliseconds. 
                                 setTimeout se utiliza para establecer un temporizador que ejecute una tarea después de un determinado tiempo. permite entender en un par de líneas la idea del asincronismo. A diferencia de una operación 
                                 síncrona, podremos notar como setTimeout inicia su ejecución, y una vez que haya transcurrido el tiempo, veremos el resultado, aun cuando el resto de las operaciones hayan terminado. 
                                                                                                                  
                                                                                                                   
  
  > setTimeout: Es una función que permite realizar acciones asincrónicamente. La función recibe dos parámetros: Una función de callback y un valor numérico que representa milisegundos. Así, la función que pasamos por primer parámetro se 
    ejecuta luego de que transcurra el tiempo definido en el segundo parámetro. Por ejemplo:
    
    setTimeout(()=> {
       console.log("Proceso asincrónico" )
    }, 3000);
    
  > CALL STACK (PILA): Es una lista donde se apilan las distintas tareas a ejecutar por nuestro programa. Javascript es un lenguaje single threaded, o de un único hilo, lo que significa que tiene un único stack o pila de ejecución. De ahí 
    que la ejecución es implícitamente sincrónica. Cuando se está a punto de ejecutar una función, ésta es añadida al stack. Si la función llama a la vez, a otra función, ésta es agregada sobre la anterior. Es igual a llamar a una funcion 
    dentro de otra funcion, ya que esta primera funcion queda pendiente su ejecucion y al termina de emplearse la segunda funcion, entonces esta desaparece y continua terminandose la primera funcion.
  
  > Callbacks: Una función callback es una función de primer nivel que se pasa a otra función como variable y ésta es ejecutada en algún punto de la ejecución de la función que la recibe.
    
  > EVENT LOOP: Muchas funciones asincrónicas se ejecutan en un stack diferente. El Event Loop es la herramienta que permite la sincronización entre nuestro call stack con estas tareas asincrónicas que funcionan en un thread aparte. Si el 
    stack está vacío, el Event Loop envía la primera función que esté en la callback queue al call stack y comienza a ejecutarse.
    
  > setInterval: Tiene la misma sintaxis que setTimeout, pero la unidad de tiempo es un intervalo para la repetición de la función asociada: Permite ejecutar funciones de manera reiterativa tras los milisegundos indicados hasta que 
    indiquemos su detención o se cierre la aplicación
    
    setInterval(() => {
       console.log("Tic")
    }, 1000)
   
  > ClearInterval & clearTimeout: En caso de querer remover un Intervalo, utilizamos la función clearInterval ().También podemos detener la ejecución de un setTimeout invocando clearTimeout ().
    Cuando llamamos un setInterval() éste retorna una referencia al intervalo generado, el cual podemos almacenar en una variable. Es esta referencia la que debemos pasar a la función clearInterval para que la limpieza tenga efecto.
    Funciona igual con los timeout. Si guardamos en una variable la referencia al timeout generado, podemos usarla para removerlo luego. En el siguiente caso, el timeout generado nunca llega a ejecutarse
    
  > Promesas (promise): Es un objeto de Javascript que representa un evento a futuro y permite representar y seguir el ciclo de vida de una tarea/operación (función). Es una acción asincrónica que se puede completar en algún momento y 
    producir un valor, y notificar cuando esto suceda. Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden ser resueltas o rechazadas.
    Podemos crear promesas a través de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una función por parámetro que a su vez recibe por parámetro las funciones de resolve y reject
    
    new Promise( (resolve, reject) => {
       //cuerpo de la promesa
    })
    
    En contra de lo que se suele pensar, la sincronicidad o asincronicidad de una promise depende de qué tarea le demos. Por defecto y diseño, lo único que ocurre de manera asincrónica es la entrega del resultado.
    Las funciones callback nunca serán llamadas previo a la terminación de la ejecución actual del bucle de eventos en JavaScript.
    Las funciones callback añadidas con .then serán llamadas después del éxito o fracaso de la operación

  
  > Resolve & Reject: En principio, una promesa se retorna con estado pending, entendiendo que el valor a generar aún no fue resuelto: 
  Esta función retorna una promesa que no se resuelve. Por lo tanto, veremos que el valor que genera es un objeto Promise con estado pendiente.

  const eventoFuturo = () => {
     return new Promise( (resolve, reject) => {
        //cuerpo de la promesa
     })
  }
  console.log( eventoFuturo() ) // Promise { <pending> }
   
  El valor de retorno de la promesa se define a través del llamado a las funciones de resolve o reject:
    ✓ Si el cuerpo de la promesa llama a resolve(), la promesa cambiará su estado a fulfilled, con el valor enviado a resolve().
    ✓ Si la promesa llama a reject(), cambiará su estado a rejected con el valor enviado al reject(). Aqui decidimos que la promesa retornara un valor que se interpreta como error y se muestra en la consola en rojo y con una x.  
       
  > Then & Catch: Al llamado de una función que retorne una promesa, podemos concatenar el método .then() o .catch(), los cuales reciben una función por parámetro con la cual se captura el valor de la promesa:
    ✓ .then():    Si la promesa es resuelta, su valor de retorno se captura dentro del .then(), recibiendo por parámetro de su función ese valor. Siempre que coloquemos un return dentro de un .then, automáticamente el resultado se convierte 
                  en otra promesa y puede ser encadenada con otro .then, y así sucesivamente hasta finalizar el proceso. Si en alguno de los .then algo llegara a salir mal, sólo se necesita un catch para atraparlo.
    ✓ .catch():   Si la promesa es rechazada, su valor se captura dentro de un .catch() siguiendo la misma lógica
    ✓ .finally() es un método que recibe una función la cual se ejecutará siempre al finalizar la secuencia, sin importar si se haya resuelto o no la promesa.
   
    Como una promesa puede tener varios estados posibles, se puede concatenar varios .then() o .catch() en un mismo llamado, y caeremos en el caso que corresponda según cómo se haya resuelto la promesa. Para cada promesa podemos definir una 
    estructura para trabajar los distintos casos posibles. Cada promesa sólo puede resolverse o rechazarse una única vez. Es un mecanismo de control claro y ordenado para trabajar la asincronía y los posibles valores a recibir.   
   
   > Try-catch: This statement is comprised of a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code 
     in the finally block will always be executed before control flow exits the entire construct.
   
   > Try-catch-throw:
     If you use the keyword 'throw' in an async function, the function will call the 'reject()' function behind the scenes and the promise will get rejected...
     However, when using try...catch block inside an async function and an error occurs in some function that returns a promise (like fetch) or if you use the 'throw' keyword yourself, the code execution will stop and move to the first 
     available catch block. So try...catch block gives you control to handle errors manually and internally and then decide how to proceed.
     For example, you could handle 10 different errors in a single or multiple try...catch blocks withing the async function and decide to reject the promise only for major errors, but still resolve it manually for smaller errors.
     The bottom line is that try...catch block gives you more control over error handling. So if you only have 1 possible error message like we do here, then you don't need the try/catch block in getJSON function nor loadRecipe function and
     the promises those functions return will normally reject/resolve based on what happened with the promises inside
   
   > fetch: Sirve para hacer peticiones HTTP a algún servicio externo. Como estas peticiones son asincrónicas, convenientemente el método fetch() trabaja con promesas. El método recibe un primer parámetro que es la URL a la cual hacer la 
     petición, y un segundo parámetro opcional de configuración: fetch(url, config). Al final, fetch retorna una nueva promesa.
     Por defecto el método fetch hace peticiones del tipo GET. Según la documentación, para obtener una lista de posts debemos hacer una petición del siguiente tipo.
     Podemos hacer un request de manera simple, utilizando Fetch API.
     Esta nos provee con una promesa, que se resuelve al terminar el request.
     Esta respuesta es una promise, que nos permite acceder a la respuesta.
       
   > Response: Llamar a fetch() retorna una promesa que resuelve en un objeto Response que contiene información sobre la respuesta del servidor, como su código de estado y headers. Para acceder al contenido de la respuesta debemos dar un 
     paso adicional, y por eso es que se ven dos .then() concatenados. Generalmente, se transfieren datos en formato JSON. Por lo tanto, para obtener el contenido de la respuesta debemos aplicar el método .json() a ese objeto. Éste retorna 
     a su vez una Promesa, por lo que capturamos su contenido (los datos enviados por la API) en un segundo .then(): 

         fetch('https://jsonplaceholder.typicode.com/posts')
           .then( (resp) => resp.json() )
           .then( (data) => {
            console.log(data)
         });
         
       En el parámetro data tenemos el contenido de la respuesta de nuestra petición. En este caso, la API nos responde con un array de 100 elemento donde cada elemento es un post.
         
  > async & await: Trabajar con promesas facilita mucho el control de los procesos asincrónicos Sin embargo, en procesos extensos se puede dificultar el trabajo escribiendo todo dentro de varios .then(). 
       Por suerte, los desarrolladores de JS ya pensaron en esto y nos ofrecen una herramienta que nos permite trabajar las promesas como si escribiéramos código sincrónico : async await.
       El método fetch retorna una promesa. De forma sincrónica, si guardamos esta promesa en una variable veremos la promesa pendiente, porque esto sucede sincrónicamente.

       const resp = fetch('https://jsonplaceholder.typicode.com/posts' ); console.log(resp) // Promise {<pending>}
       
    Significa que el console.log() no espera a que se resuelva la promesa de la línea anterior para ejecutarse.

    ✓ async: Se colocará al inicio de una función, indicando que todo el cuerpo de esa función deberá ejecutarse de manera asíncrona 
      Esta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función. Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a 
      que se resuelvan las promesas vistas para continuar con la instrucción siguiente.
      Lo que hace await es detener la ejecución y no continuar. Se espera a que se resuelva la promesa, y hasta que no lo haga, no continua. A diferencia del fetch(), tenemos un código bloqueante.
      
    ✓ await: servirá (como indica su nombre) para esperar por el resultado de la promesa y extraer su resultado. Al ser operaciones que podrían salir bien, PERO TAMBIÉN MAL, es importante encerrar el cuerpo en un bloque try {} catch {} 
      Nos permite establecer un punto de espera en el código. Aplicado como prefijo a una promesa (en este caso, el return del fetch) se bloquea la ejecución de la siguiente instrucción hasta que la promesa se resuelva.     
      Lo malo es que await sólo puede utilizarse dentro de una función asincrónica. Aquí es donde entra la sentencia async. Ésta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función.             
      Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a que se resuelvan las promesas vistas para continuar con la instrucción siguiente. 

   > micro-tasks queue: 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Ajax & FETCH & WEB API'S

- fetch: Fetch is the retrieval of data by a software program, script, or hardware device. After being retrieved, the data is moved to an alternate location or displayed on a screen.

- Hoisting: Es el proceso de mover todas las declaraciones de variables a la parte superior de la función o del entorno. El concepto de hoisting de JavaScript determina que el valor de una variable declarada con var puede subir al 
  principio del scope de la función dentro de la que está declarada. Esto puede ser peligroso, porque puedes terminar con un valor de tipo undefined a pesar de haberle otorgado valor a tus variables. Es decir, la palabra clave var a veces 
  nos sorprende con valores indefinidos en variables definidas. El hoisting de JavaScript raras veces genera este comportamiento en variables declaradas con const y con let. Aunque puede suceder, el desarrollador web casi que tiene que 
  generar este comportamiento a propósito para que suceda.  
  
- Asincrónia: La programación asíncrona nos da la capacidad de “diferir” la ejecución de una función a la espera de que se complete una operación, normalmente de I/O (red, disco duro, …), y así evitar bloquear la ejecución hasta que se haya 
  completado la tarea en cuestión. Esto es posible gracias a que las funciones son ciudadanos de primer nivel (first-class citizens) y pueden ser pasadas como argumentos de otras funciones tal cual lo haríamos con las variables.                                                                                                                   
  
-  Node JS: Node.js es un entorno de ejecución de JavaScript, que le permite al código en js ser ejecutado en nuestra computadora. Podemos darle a node un archivo de js y éste puede ejecutarlo, y darle acceso a recursos de nuestra 
   computadora (IO, Network, Etc). El “Node” de java es conocido como la JVM.
   
-  NPM (Node Packager Manager): Cuando usamos Node.js, rápidamente tenemos que instalar módulos nuevos (librerías), ya que al ser un sistema fuertemente modular viene prácticamente “vacío”. Por lo tanto, para utilizar una funcionalidad de 
   alguna librería publicada, deberemos instalar módulos adicionales. Esta operación se realiza de forma muy sencilla con la herramienta npm (Node Package Manager).
   Esta herramienta funciona de dos formas:
     ✓ Como un repositorio ampliamente utilizado para la publicación de proyectos Node.js de código abierto.
     ✓ Como una herramienta de línea de comandos. Esta utilidad ayuda a instalar y desinstalar paquetes, gestionar versiones y gestionar dependencias necesarias para ejecutar un proyecto.

- JSON (JavaScript Object Notation): It is a format for storing and transporting data. JSON is text, and text can be transported anywhere, and read by any programming language. Es un formato basado en texto plano de intercambio de datos 
  totalmente independiente del lenguaje de programación, para representar datos estructurados con la sintaxis de objetos de JavaScript. Es comúnmente utilizado para enviar y almacenar datos o información estructurada en aplicaciones web, 
  entre un servidor y un cliente. Aunque es muy parecido a la sintaxis de JavaScript, puede ser utilizado independientemente de JavaScript, y muchos entornos de programación poseen la capacidad de leer (convertir; parsear) y generar JSON. 
  JSON es un string con un formato específico. Otros puntos a tener en cuenta son:
  
     ~ Los datos contenidos en un archivo en formato JSON deben estructurarse por medio de una colección de pares con nombre y valor o deben ser una lista ordenada de valores. Sus elementos tienen que contener:
        + Clave: corresponde al identificador del contenido. Por eso, debe ser una string delimitada por comillas.
        + Valor: representa el contenido correspondiente y puede contener los siguientes tipos de datos: string, array, object, number, boolean o null.
     ~ Las datos en formato JSON se pueden almacenar en archivos externos .json. Exemplo: datos.json 
     ~ JSON es sólo un formato de datos - contiene sólo propiedades, no métodos.
     ~ A diferencia del código JavaScript en que las propiedades del objeto pueden no estar entre comillas, en JSON sólo las cadenas entre comillas pueden ser utilizadas como propiedades.
     ~ JSON es solo un formato de datos.
     ~ Requiere usar comillas dobles para las cadenas y los nombres de propiedades. Las comillas simples no son válidas. 
     ~ Puede tomar la forma de cualquier tipo de datos que sea válido para ser incluido en un JSON, no solo arreglos u objetos. Así, por ejemplo, una cadena o un número único podrían ser objetos JSON válidos.
     ~ A diferencia del código JavaScript, en el que las propiedades del objeto pueden no estar entre comillas, en JSON solo las cadenas entre comillas pueden ser utilizadas como propiedades.
      
  La transferencia de datos entre aplicaciones es realizada por medio de API —Application Programming Interface— que, entre otros formatos, utiliza la notación JSON para estructurar la información enviada.
  El archivo JSON también se usa para realizar requisiciones AJAX en sitios web, en que se hacen diferentes interacciones con bancos de datos, como el MySql, para realizar operaciones como consulta, inclusión y exclusión de registros.
  
  Principales casos de uso para JSON:
     ~ Generación de un objeto JSON a partir de datos generados por el usuario: JSON es perfecto para el almacenamiento de datos temporales. Por ejemplo, los datos temporales pueden ser generados por el usuario, como un formulario enviado en 
       un sitio web. JSON también se puede utilizar como formato de datos para cualquier lenguaje de programación a fin de incrementar el nivel de interoperabilidad.
     ~ Tansferencia de datos entre sistemas: Una base de datos de sitio web tiene la dirección postal de un cliente, pero la dirección debe verificarse a través de una API para garantizar su validez. Envío de los datos de dirección en 
       formato JSON a la API de servicio de validación de direcciones.
     ~ Configuración de datos para aplicaciones: Al desarrollar aplicaciones, cada aplicación necesita las credenciales para conectarse a una base de datos, así como una ruta de acceso al archivo log. Las credenciales y la ruta de acceso al 
       archivo se pueden especificar en un archivo JSON que sea legible y que esté siempre disponible.
     ~ Simplificación de modelos de datos complejos: JSON simplifica los documentos complejos hasta los componentes que se han identificado como significativos mediante la conversión del proceso de extracción de datos en un archivo JSON 
       predecible y legible por humanos.
     
- API (Application Programming Interfaces): que en español significa interfaz de programación de aplicaciones. Es una aplicación web construida en base a la arquitectura API REST, a la cual podemos solicitar y enviar información desde el 
  cliente. Tambien, se define como un conjunto de definiciones y reglas que permiten que dos equipos puedan integrarse para trabajar juntos. La mejor analogía que hay para comprender ésto es que una API funge como un “contrato” entre el 
  front y el back. La API permite entonces que se respondan preguntas como:
    ✓ ¿A qué endpoint debo apuntar para la tarea que necesito?
    ✓ ¿Qué método debo utilizar para ese recurso?
    ✓ ¿Qué información debo enviar para realizar correctamente mi petición? 
    
  1) REST: Ya tenemos las reglas para comunicarse, ¿Pero qué tal la estructura del mensaje? Cuando hacemos una petición o cuando recibimos una respuesta, ésta debe tener un formato. REST (REpresentational State Transfer) permite definir la 
     estructura que deben tener los datos para poder transferirse. La API respondía a preguntas sobre cómo comunicarse correctamente, sin embargo, REST define cómo debe ser el cuerpo del mensaje a transmitir. (puedes llegar a hablar con el 
     presidente si cumples con el protocolo (HTTP) y las reglas (API), pero ¿de qué nos servirá si la forma en que estructuramos nuestro mensaje (REST) no es correcta?).
     Los dos formatos más importan tes son JSON y XML. La utilización de la estructura dependerá de las necesidades del proyecto. Nosotros utilizaremos JSON. Como otarás, ¡un JSON parece un objeto! así que es mucho más amigable la sintaxis.
  2) API REST es: Un modelo completo para tener perfectamente estipulados los protocolos, las reglas, e incluso la estructura de la información, con el fin de poder hacer un sistema de comunicación completo entre las computadoras.
  3) Características debe tener una API REST: Estas son las caracteristicas mas importantes de una API REST
     a) Arquitectura Cliente-Servidor sin estado: 
        ~ Cada mensaje HTTP contiene toda la información necesaria para comprender la petición. 
        ~ Como resultado, ni el cliente ni el servidor necesitan recordar ningún estado de las comunicaciones entre mensajes.
        ~ Esta restricción mantiene al cliente y al servidor débilmente acoplados: el cliente no necesita conocer los detalles de implementación del servidor y el servidor se “despreocupa” de cómo son usados los datos que envía al cliente.
     b) Cacheable: 
        ~ Debe admitir un sistema de almacenamiento en caché.  
        ~ La infraestructura de red debe soportar una caché de varios niveles. 
        ~ Este almacenamiento evita repetir varias conexiones entre el servidor y el cliente, en casos en que peticiones idénticas fueran a generar la misma respuesta.
     c) Operaciones comunes:
        ~ Todos los recursos detrás de nuestra API deben poder ser consumidos mediante peticiones HTTP, preferentemente sus principales (POST, GET, PUT y DELETE).
        ~ Con frecuencia estas operaciones se equiparan a las operaciones CRUD en bases de datos (en inglés: Create, Read, Update, Delete, en español: Alta, Lectura, Modificación, y Baja).  
        ~ Al tratarse de peticiones HTTP, éstas deberán devolver con sus respuestas los correspondientes códigos de estado, informando el resultado de las mismas. 
     d) Interfaz uniforme: 
        ~ En un sistema REST, cada acción (más correctamente, cada recurso) debe contar con una URI (Uniform Resource Identifier), un identificador único.  
        ~ Ésta nos facilita el acceso a la información, tanto para consultarla, como para modificarla o eliminarla, pero también para compartir su ubicación exacta a terceros.
     e) Utilización de hipermedios: 
        ~ Cada vez que se hace una petición al servidor y este devuelve una respuesta, parte de la información devuelta pueden ser también hipervínculos de navegación asociada a otros recursos del cliente.
        ~ Como resultado de esto, es posible navegar de un recurso REST a muchos otros, simplemente siguiendo enlaces sin requerir el uso de registros u otra infraestructura adicional
     
  
  Generalmente, nos comunicamos con aplicaciones de este tipo y es la tendencia actual de desarrollo. La ventaja de este modelo es que está orientado a recursos y define métodos claros para solicitar y enviar información. Una API
  suele tener una URL base (el dominio donde está alojada la aplicación) y luego puede tener varios endpoints, es decir, distintas secciones a las que podemos acceder. A la vez, se pueden hacer peticiones con distintos métodos al mismo 
  endpoint y obtener distintos resultados. Generalmente, similar a cuando queremos incorporar una librería, al momento de consumir una API debemos revisar su documentación. Allí se definen los distintos endpoints disponibles, los métodos a 
  utilizar para hacer una petición y qué se nos ofrecerá en respuesta.
  Se trata de un conjunto de definiciones y protocolos que se utiliza para desarrollar e integrar el software de las aplicaciones, permitiendo la comunicación entre dos aplicaciones de software a través de un conjunto de reglas. Así pues, 
  podemos hablar de una API como una especificación formal que establece cómo un módulo de un software se comunica o interactúa con otro para cumplir una o muchas funciones. Todo dependiendo de las aplicaciones que las vayan a utilizar, y de 
  los permisos que les dé el propietario de la API a los desarrolladores de terceros.
  
  Una de las principales funciones de las API es poder facilitarle el trabajo a los desarrolladores y ahorrarles tiempo y dinero. Por ejemplo, si estás creando una aplicación que es una tienda online, no necesitarás crear desde cero un 
  sistema de pagos u otro para verificar si hay stock disponible de un producto. Podrás utilizar la API de un servicio de pago ya existente, por ejemplo PayPal, y pedirle a tu distribuidor una API que te permita saber el stock que ellos 
  tienen. Con ello, no será necesario tener que reinventar la rueda con cada servicio que se crea, ya que podrás utilizar piezas o funciones que otros ya han creado. Imagínate que cada tienda online tuviera que tener su propio sistema de 
  pago, para los usuarios normales es mucho más cómodo poder hacerlo con los principales servicios que casi todos utilizan. También son útiles para cuando lo único que se quiere es utilizar deliberadamente las funciones de determinado 
  servicio para ofrecer ventajas a sus usuarios o atraer a los usuarios de ese servicio a que utilicen tu aplicación.


- Peticiones HTTP: El mecanismo por el cual se piden y proveen datos a través de internet es HTTP (Hypertext Transfer Protocol). Cuando emitimos una orden al navegador, hace una petición (o request) HTTP a algún servidor. Luego, la recibirá, 
  procesará y nos devolverá una respuesta con información que utilizaremos en la aplicación. Estas peticiones que debemos hacer están definidas por varias partes
  
  > Una URL o dirección: Cuando nos comunicamos con un servidor para pedir información lo hacemos a través de una URL, ya que éste es un programa alojado en algún host y nos comunicamos con él a través de la dirección correcta
  
  > MÉTODO (method): Un método es una definición que forma parte del protocolo HTTP, el cual nos sirve para canalizar el tipo de petición queestoy realizando sobre un cierto endpoint. De esta manera, el cliente puede llamar al mismo 
    endpoint, pero con diferentes métodos, indicando qué operación quiere realizar con dicho recurso.
    Cada petición que hacemos está acompañada por un verbo que indica al servidor cuál es nuestra intención. El servidor tiene la capacidad de escuchar distintas peticiones en la misma URL, decidir a cuál responder y cómo.     
    Son 4 los verbos más utilizados, aunque hay muchos más: Get, Post, Put & Delete. Las peticiones de tipo POST y PUT van acompañadas de un body (cuerpo de la request) donde se definen los datos o información a enviar al servidor. GET o 
    DELETE, por su parte, no tienen body ya que no necesitan enviar datos adjuntos.
   
    ~ GET: Para obtener información (o recurso) del servidor. Suelen ser las más utilizadas.
   
    ~ POST: Para enviar información al servidor para crear algún recurso.  Significa que el método de la petición será POST Si no lo modificamos será de tipo GET por defecto. Sirve para “crear” recursos, POST se utiliza para operaciones 
      donde no necesitamos obtener un recurso, sino añadir uno. Algunos de los casos donde se utilizan son: Registrar un usuario: Loguear un usuario, Crear un producto, Crear carrito de compra, Enviar información para un correoelectrónico. 
      Se apoya del recurso req.body, donde el body representa la información que el cliente envía para crear. 
    
    ~ PUT: Para crear o modificar algún recurso en el servidor. En este caso se deben mandar todos los elementos contenidos en el objeto aunque solo se desee modificar unos solo. 
      
    ~ PATCH: quiero alterar parcialmente. Aqui, unicamente se puede enviar un elemento de todos los contenidos en el objeto. 
    
    ~ DELETE: Para eliminar algún recurso en el servidor
    
    Estos verbos Nos permiten definir una manera de explicarle al servidor la dirección y nuestras intenciones. Ningún verbo representa una seguridad y/u obligación. Pero si el servidor y el consumidor los respetan, se pueden lograr algunas 
    mejoras como por ejemplo: El navegador sabe que un POST no debería ser cacheado, si hacemos un GET y fuera cacheable el navegador podrá cachearlo, pero nunca lo hará con un recurso con verbo POST
    
    ~ BODY: Es el espacio en la petición donde se definen los datos a enviar al servidor. Aquí se adjuntan los datos a enviar al servidor. En este caso se envía un objeto con la forma { title, body, userId }. 
      El body debe enviarse en formato JSON, por eso lo vemos envuelto en un JSON.stringify(). Se utiliza para transferir piezas de información entre el cliente y el servidor.
      
    ~ HEADERS: Las cabeceras (headers) HTTP permiten al cliente y servidor enviar información sobre la petición y la respuesta. Los headers incluyen información sobre la petición para establecer una transferencia segura y clara, y de ser 
      necesario se pueden modificar para agregar datos adicionales. No debemos confundir información sobre la petición (headers) con los datos que la petición puede transferir (body).
      En este caso se agrega una propiedad ‘Content-type’, con el valor que nos indica la documentación de la API Si no se agrega la petición sería rechazada por el servidor.
      Headers: Se usan para: Definir las respuestas soportadas, requeridas o preferidas. Agregar información extra. Auth tokens, cookies. Lenguaje preferido. Si acepta contenido cacheado. Lo que quieras en forma de texto.
      
    ~ Parámetros (Query Params o URL Params): Para especificar una petición, se puede enviar información adicional en la forma de parámetros a través de la URL. Tenemos dos formas de definir parámetros a través de la URL: 
      ● Query params: Permite adjuntar en la URL una serie de parámetros en la forma de pares clave-valor. Por ejemplo, si queremos buscar algo por google, debemos enviarle un valor de búsqueda por el parámetro q, a través de la url. Se 
        utiliza el símbolo ? para indicar el final de la parte de la dirección de la url y el comienzo del query. A partir de ahi, se escriben parámetros con la Forma clave=valor, pudiendo definir varios separándolos con el signo (&).
      ● URL params: Esta sintaxis permite enviar parámetros directamente en la forma de segmentos de la URL, es decir separados por / . Por ejemplo, la PokeApi nos indica lo siguiente:     https://pokeapi.co/api/v2/pokemon/{id or name}/ 
        Significa que ese {id or name} es un parámetro, un valor dinámico que insertamos en la URL, en este caso para obtener información sobre un pokemon según su ID o nombre. Para obtener aquel con id = 1, haríamos una petición GET a la
        siguiente url:       https://pokeapi.co/api/v2/pokemon/1    
        
      Nos permiten incluir en la dirección información que se usa para especificarle al receptor parámetros para efectuar una búsqueda, son más comunes para buscar recursos que no tengo la seguridad de 
      que existan. Se puede leer como:
       + busca en google.com.ar
       + utilizando https…
       + el recurso search (resultados de búsqueda) …
       + que contengan la palabra (q = query) ‘coderhouse’
       + Se separa la URL de los parámetros utilizando un signo de pregunta ?
       + Cada parámetro tendra key=value & key2=value2
       + Cada parámetro se puede separar por &
       + http://url.com/find?type=order&id=1234
       
  > Principios
    ✓ Una aplicación RESTful requiere un enfoque de diseño distinto a la forma típica de pensar en un sistema: lo contrario a RPC
    ✓ RPC (Remote Procedure Calls, llamadas a procedimientos remotos) basa su funcionamiento en las operaciones que puede realizar el sistema (acciones, usualmente verbos). Ej: getUsuario()
    ✓ En REST, por el contrario, el énfasis se pone en los recursos (usualmente sustantivos), especialmente en los nombres que se le asigna a cada tipo de recurso. Ej. Usuarios.
    ✓ Cada funcionalidad relacionada con este recurso tendría sus propios identificadores y peticiones en HTTP.
       
     ~ URL Params: Son una convención para incluir el identificador del recurso dentro de la misma url, son más comunes cuando ya se conoce el recurso específico que se buscará.
     
     ~ RECURSOS/RESTFUL: Cuando se crea y provee un servicio basado y pensado en términos de recursos, y se respetan las convenciones de verbo/método y código de respuesta, estamos frente a un diseño arquitectural de tipo REST.
       Si además transferimos javascript o xml, es conocido como AJAX



- Query: Es una solicitud pero con ciertos parametros de busqueda. Se entiende por query o consulta cualquier petición de datos hacia un servicio que los devuelva, como puede ser una base de datos. Dentro de las bases de datos, Query hace 
  referencia a la repetición de datos que se encuentran almacenados. Por otra parte, Query también es el término de consulta que deriva en una SERP dentro de los buscadores. De esta manera, esta herramienta tiene como objetivo facilitar los 
  resultados arrojados a una solicitud. Query en bases de datos SQL y NoSQL es una técnica para obtener esos datos que se planea analizar. Por ejemplo, podrás pedir todos los datos del usuario y, además, podrás seleccionar la tabla o pedir 
  una hoja específica donde se encuentren las direcciones.
    
- AJAX (Asynchronous JavaScript and XML): Es un conjunto de técnicas de desarrollo que permiten que las aplicaciones web funcionen de forma asincrónica para procesar tareas en segundo plano. En consecuencia, cualquier app o web que emplee 
  AJAX puede enviar y recibir datos sin volver a cargar toda la página, evitando la interrupción de acciones realizadas por el usuario, añadiendo interactividad y dinamismo a nuestra aplicación. El objetivo principal de AJAX es hacer que los 
  sitios y las aplicaciones web sean más fáciles de usar, más rápidos y con mayor capacidad de respuesta. AJAX tiene ciertas ventajas indiscutibles como:
    > Facilita la navegación, ya que la información se actualiza continuamente y las interacciones entre el usuario y las páginas web se vuelven más rápidas.
    > Reduce la carga en el servidor, aumentando su velocidad y capacidad, porque no se genera la información de la página completa, sino de una sola parte que debe actualizarse.
    > Aumenta la interactividad porque los resultados de búsqueda aparecen inmediatamente, lo que optimiza el proceso de búsqueda y mejora la experiencia del usuario.

  El modelo práctico de uso de AJAX tiene los siguientes pasos:
    > Paso 1. En el navegador se crea una llamada de JavaScript que activa XMLHttpRequest.
    > Paso 2. En segundo plano el navegador web crea una solicitud HTTP que va al servidor.
    > Paso 3. El servidor recibe, recupera y manda los datos al navegador web.
    > Paso 4. Los datos se reciben por la web y aparecen en la página sin que se recargue.
    
  En el modelo tradicional se crea una solicitud HTTP que va al servidor. El servidor procesa la solicitud y carga la página HTML sin que el usuario interactúe con la aplicación web. En el caso de AJAX, JS permite que el usuario interactúe 
  con la aplicación web y modifique la página en segundo plano y solo sus partes necesarias. “En segundo plano” significa que mientras espera que se reciban los datos, el usuario puede hacer otras cosas en la página y optimizar este tiempo.
 
- Promesas (promise): Es un objeto de Javascript que representa un evento a futuro y permite representar y seguir el ciclo de vida de una tarea/operación (función). Es una acción asincrónica que se puede completar en algún momento y 
  producir un valor, y notificar cuando esto suceda. Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden ser resueltas o rechazadas.
  Podemos crear promesas a través de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una función por parámetro que a su vez recibe por parámetro las funciones de resolve y reject
  
 
- XML (Extensible Markup Language): es un lenguaje de marcado que define un conjunto de reglas para la codificación de documentos. El lenguaje de marcado es un conjunto de códigos que se pueden aplicar en el análisis de datos o la lectura de 
  textos creados por computadoras o personas. El lenguaje XML proporciona una plataforma para definir elementos para crear un formato y generar un lenguaje personalizado. XML admite el intercambio de información entre sistemas de 
  computación, como sitios web, bases de datos y aplicaciones de terceros. Las reglas predefinidas facilitan la transmisión de datos como archivos XML a través de cualquier red, ya que el destinatario puede usar esas reglas para leer los 
  datos de forma precisa y eficiente.
  Un archivo XML se divide en dos partes: prolog y body. La parte prolog consiste en metadatos administrativos, como declaración XML, instrucción de procesamiento opcional, declaración de tipo de documento y comentarios. La parte del body se 
  compone de dos partes: estructural y de contenido (presente en los textos simples). El diseño XML se centra en la simplicidad, la generalidad y la facilidad de uso y, por lo tanto, se utiliza para varios servicios web. Tanto es así que hay 
  sistemas  destinados a ayudar en la definición de lenguajes basados ​​en XML, así como APIs que ayudan en el procesamiento de datos XML - que no deben confundirse con HTML.
  
- Microservicio: Los microservicios son un enfoque arquitectónico y organizativo para el desarrollo de software donde el software está compuesto por pequeños servicios independientes que se comunican a través de API bien definidas. Los 
  propietarios de estos servicios son equipos pequeños independientes. Las arquitecturas de microservicios hacen que las aplicaciones sean más fáciles de escalar y más rápidas de desarrollar. Esto permite la innovación y acelera el tiempo de 
  comercialización de las nuevas características.
  Los microservicios son tanto un estilo de arquitectura como un modo de programar software. Con los microservicios, las aplicaciones se dividen en sus elementos más pequeños e independientes entre sí. A diferencia del enfoque tradicional y 
  monolítico de las aplicaciones, en el que todo se compila en una sola pieza, los microservicios son elementos independientes que funcionan en conjunto para llevar a cabo las mismas tareas. Cada uno de esos elementos o procesos es un 
  microservicio. Este enfoque de desarrollo de software valora el nivel de detalle, la sencillez y la capacidad para compartir un proceso similar en varias aplicaciones. Es un elemento fundamental de la optimización del desarrollo de ap
  licaciones hacia un modelo nativo de la nube.
  Sin embargo, el mayor interrogante es cuáles son las ventajas de utilizar una infraestructura de microservicios. En pocas palabras, el objetivo es distribuir software de calidad con mayor rapidez. Si bien esto se puede lograr con los 
  microservicios, se deben considerar otras cuestiones. Dividir las aplicaciones en microservicios no es suficiente; es necesario administrarlos, coordinarlos y gestionar los datos que crean y modifican.

- Libreria: Las librerías de programación son conjuntos de archivos de código que se utilizan para desarrollar software. Su objetivo es facilitar la programación, al proporcionar funcionalidades comunes, que ya han sido resueltas previamente 
  por otros programadores. Como curiosidad, el término proviene de una mala traducción de la palabra inglesa library, que en realidad significa biblioteca. Las librerías (o bibliotecas) son un componente esencial para que los desarrolladores 
  puedan programar de forma sencilla, evitando la duplicidad de código y minimizando errores. También permiten una mayor agilidad, al reducir el tiempo de desarrollo, así como los costes. A diferencia de un framework, una librería no aporta 
  la estructura sobre cómo realizar el desarrollo, sino que proporciona funcionalidades comunes, que ya han sido resueltas previamente por otros programadores y evitan la duplicidad de código. Además reducen el tiempo de desarrollo y 
  aumentan la calidad del mismo.
   > Librerías estáticas: Estas se graban en un programa como ejecutables. Sirven exclusivamente para esto; después, podemos borrarlas sin problemas, ya que el programa seguirá funcionando con la función necesaria.  
   > Librerías dinámicas: Son distintas a las estáticas en tanto en cuanto no se copian en el programa al compilarlas. Las subrutinas son cargadas en tiempo de ejecución, en vez de enlazarse en tiempo de compilación.  

- Framework: un framework es un marco de trabajo que tiene como objetivo facilitar la solución de problemas que pueden surgir al programar. Los frameworks aceleran el proceso de programar facilitando tareas como la organización del código o 
  el trabajo en equipo dentro de un proyecto, por ejemplo. En otras palabras, el objetivo de un framework en programación es facilitar la tarea de los programadores.
  También hay que destacar que muchos de estos frameworks no sólo facilitan la organización del trabajo, sino que también ofrecen recursos desarrollados por otros programadores. Estos recursos pueden ser informes o códigos que pueden usarse 
  para solucionar los problemas más habituales que se dan al llevar a cabo determinadas tareas.
    > Frameworks para software development: Los frameworks para aplicaciones generales se utilizan para mejorar la estructura de una aplicación. Su objetivo es proporcionar una estructura base para los desarrolladores de software con la que 
      puedan organizar sus proyectos. Eso sí, siempre dentro de un sistema operativo determinado. 
    > Frameworks para desarrollo web: Al estar relacionados con el diseño web, es evidente que existen diferentes frameworks para los diferentes lenguajes de programación que se utilizan. Un desarrollador backend y uno de frontend usarán 
      marcos de trabajo distintos, aunque existen algunos ideales para los full stack developers como ReactJS.
    > Marco de gestión de contenido: De nuevo, un tipo de frameworks relacionados con el diseño web. Aun así, en este caso se trata de interfaces diseñadas para personalizar un CMS. En consecuencia, existen una gran cantidad de CMFs, ideales 
      para diferentes lenguajes e incluso para diferentes tareas dentro de un lenguajes.
    
- Servidor: un equipo informático que forma parte de una red y provee servicios a otros equipos. Es un aparato informático que almacena, distribuye y suministra información. Los servidores funcionan basándose en el modelo “cliente-servidor”. 
  El cliente puede ser tanto un ordenador como una aplicación que requiere información del servidor para funcionar. Por tanto, un servidor ofrecerá la información demandada por el cliente siempre y cuando el cliente esté autorizado. Los 
  servidores pueden ser físicos o virtuales.
  > Servidor proxy: realiza un cierto tipo de funciones a nombre de otros clientes en la red para aumentar el funcionamiento de ciertas operaciones (p. ej., prefetching y depositar documentos u otros datos que se soliciten muy 
    frecuentemente), también proporciona servicios de seguridad, o sea, incluye un cortafuegos.
  > Servidor del acceso remoto (RAS): controla las líneas de módem de los monitores u otros canales de comunicación de la red para que las peticiones conecten con la red de una posición remota, responde llamadas telefónicas entrantes y 
    reconoce la petición de la red.
  > Servidor web: almacena documentos HTML, imágenes, archivos de texto, escrituras, y demás material Web compuesto por datos (conocidos colectivamente como contenido), y distribuye este contenido a clientes que la piden en la red.
  > Servidor de base de datos: provee servicios de base de datos a otros programas u otras computadoras, como es definido por el modelo cliente-servidor. También puede hacer referencia a aquellas computadoras (servidores) dedicadas a 
    ejecutar esos programas, prestando el servicio.
     
- codigo de estado: Cuando realizamos alguna petición al servidor mediante el protocolo HTTP, el servidor debe respondernos no sólo con información, sino con un estado del proceso. Este es un código que nos permitirá saber cómo se encuentra 
  el proceso, o cómo finalizó.    
  
- HTTP: Acrónimo para Hyper Text Transfer Protocol. Es el protocolo que nos permite comunicarnos a través de Internet  
- Protocolo: Conjunto de estándares y normas que deben seguirse para poder llevar a cabo una comunicación correcta
- Servidor: Sistema que permite recibir peticiones de otras computadoras y devolver una respuesta a éstas
- HTTP response status codes: HTTP response status codes indicate whether a specific HTTP request has been successfully completed. Cuando el servidor responde con un código de estado, esto permite saber qué ocurrió con la consulta que 
  estábamos haciendo, y da información al cliente sobre qué ha ocurrido.
  ✓ 1xx: Status “informativo”
  ✓ 2xx: Status “ok”. Indica que la petición se procesó correctamente. No hubo ningún tipo de inconveniente desde la consulta hasta la respuesta.
  ✓ 3xx: Status de redirección. Hace referencia a redirecciones, cuando un recurso se ha movido o necesitamos apuntar a otro servicio.
  ✓ 4xx: Status de error de cliente. Se utiliza cuando el cliente realiza alguna petición que no cumpla con las reglas de comunicación (una mala consulta, tal vez le faltó enviar un dato, o venía en un formato incorrecto).
  ✓ 5xx: Status de error en servidor.
  
  ~ 200: Indica que la petición se procesó correctamente. No hubo ningún tipo de inconveniente desde la consulta hasta la respuesta
  ~ 300: Hace referencia a redirecciones, cuando un recurso se ha movido o necesitamos apuntar a otro servicio.
  ~ 400: Se utiliza cuando el cliente realiza alguna petición que no cumpla con las reglas de comunicación (una mala consulta, tal vez le faltó enviar un dato, o venía en un formato incorrecto).
  ~ 401: Se utiliza cuando el cliente no se ha identificado con el servidor bajo alguna credencial, no puede acceder al recurso
  ~ 404: Se utiliza cuando el recurso no se ha encontrado, ya sea algún dato solicitado o incluso el endpoint mismo.
  ~ 500: Se utiliza cuando algo ocurrió en el servidor, no necesariamente un error del cliente, sino un error o “detalle” que no haya considerado el servidor al tratar con algún caso
       
       
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   WEB API'S

> IntersectionObserver: The IntersectionObserver interface of the Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's 
  viewport. The ancestor element or viewport is referred to as the root.
  When an IntersectionObserver is created, it's configured to watch for given ratios of visibility within the root. The configuration cannot be changed once the IntersectionObserver is created, so a given observer object is only useful for 
  watching for specific changes in degree of visibility; however, you can watch multiple target elements with the same observer.            
  
  ~ constructor: The IntersectionObserver() constructor creates and returns a new IntersectionObserver object.
    The rootMargin, if specified, is checked to ensure it's syntactically correct. If not specified, or an empty string, the default is 0px 0px 0px 0px.
    The thresholds, if specified, are checked to ensure that they're all in the range 0.0 and 1.0 inclusive, and the threshold list is sorted in ascending numeric order. If the threshold list is empty, it's set to the array [0.0].      
  
                                                                                   new IntersectionObserver(callback, options);
  
    callback: A function which is called when the percentage of the target element is visible crosses a threshold. The callback receives as input two parameters:
    
    entries: An array of IntersectionObserverEntry objects, each representing one threshold which was crossed, either becoming more or less visible than the percentage specified by that threshold.
    
    observer: The IntersectionObserver for which the callback is being invoked.
    
    options Optional: An optional object which customizes the observer. If options isn't specified, the observer uses the document's viewport as the root, with no margin, and a 0% threshold (meaning that even a one-pixel change is enough to
    trigger a callback). You can provide any combination of the following options:
    
    root: An Element or Document object which is an ancestor of the intended target, whose bounding rectangle will be considered the viewport. Any part of the target not visible in the visible area of the root is not considered visible.
    root property identifies the Element or Document whose bounds are treated as the bounding box of the viewport for the element which is the observer's target. 
    If the root is null, then the bounds of the actual document viewport are used, the owning document is used as the root, and the bounds its viewport (that is, the visible area of the document) are used as the root bounds.
    
    rootMargin: A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections, effectively shrinking or growing the root for calculation purposes. The syntax is approximately the same as that for 
    the CSS margin property; see The intersection root and root margin for more information on how the margin works and the syntax. The default is "0px 0px 0px 0px".
    
    threshold: Either a single number or an array of numbers between 0.0 and 1.0, specifying a ratio of intersection area to total bounding box area for the observed target. A value of 0 means that even a single visible pixel counts as the 
    target being visible. 1.0 means that the entire target element is visible. See Thresholds for a more in-depth description of how thresholds are used. The default is a threshold of 0.0.                                                                                                                                                                                 
    
    
    disconnect(): stops watching all of its target elements for visibility changes.
    
    observe(): adds an element to the set of target elements being watched by the IntersectionObserver. One observer has one set of thresholds and one root, but can watch multiple target elements for visibility changes in keeping with those.
    To stop observing the element, call IntersectionObserver.unobserve().
    
    takeRecords(): returns an array of IntersectionObserverEntry objects, one for each targeted element which has experienced an intersection change since the last time the intersections were checked, either explicitly through a call to this 
    method or implicitly by an automatic call to the observer's callback.
    
    unobserve(): instructs the IntersectionObserver to stop observing the specified target element.
    
- FormData(): The FormData interface provides a way to construct a set of key/value pairs representing form fields and their values, which can be sent using the fetch(), XMLHttpRequest.send() or navigator.sendBeacon() methods. It uses the 
  same format a form would use if the encoding type were set to "multipart/form-data"    
  
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Express

- Express js es un framework minimalista que permitirá desarrollar servidores más complejos. Éste nos facilitará:
   ✓ Utilizar diferentes rutas para las peticiones.
   ✓ Mejorar la estructura de nuestro proyecto.
   ✓ Manejar funcionalidades más complejas y utilización de middlewares. 
  
  + Paso 1: npm init -y                                                                                                                   
    Express no es nativo de nodejs, por lo tanto, necesitaremos primero contar con un package.json para gestionar las dependencias a instalar. 
    Una vez que tenemos package.json en nuestra carpeta, podemos continuar instalando dependencias.
  
  + Paso 2: npm install express 
    Procedemos a instalar de manera local express js. Al ejecutar este comando, notaremos cómo se genera una carpeta node_modules, que es donde se encuentra almacenado express.
    A partir de este punto, ya contamos con la estructura elemental instalada, el resto es más “flexible”.

  + Paso 3: Estructurar el proyecto 
    Se recomienda tener una carpeta src, donde vivirá todo nuestro código, dentro del cual crearemos un archivo con el nombre “app.js”
    Finalmente, el archivo app.js ya puede importar la dependencia instalada de express js, ya sea por commonjs:   const express = require ("express");
    o bien por module (recordar colocar el type:”module” en package.json):   import express from "express";                                           
  
  + Ejemplo de una consulta en Express
     ✓ Estructurar un servidor basado en express, el cual escuche peticiones en el puerto 8080
     ✓ Realizar una función para el método GET en la ruta ‘/saludo’, el cual responderá con “¡Hola a todos, pero ahora desde express!”
     ✓ Ejecutar con nodemon (npm install -g nodemon) y probar en el navegador el endpoint generado.
     
- Método GET: Método del protocolo HTTP que permite indicar al servidor que deseamos hacer na consulta de obtención de datos.       .get() 
- Metodo POST: Sirve para “crear” recursos, POST se utiliza para operaciones donde no necesitamos  obtener un recurso, sino añadir uno. Algunos de los casos donde se utilizan son:
    ✓ Registrar un usuario
    ✓ Loguear un usuario
    ✓ Crear un producto
    ✓ Crear una mascota
    ✓ Crear un carrito de compra
    ✓ Enviar información para un correo electrónico.
  Se apoya del recurso req.body, donde elbody representa la información que el cliente envía para crear.
- Método PUT: Sirve Para poder trabajar con PUT, no sólo enviamos el body en el request, sino que demás mandamos por params el id, nombre,  cualquier identificador para que el servidor epa qué recurso específicamente debe ctualizar.
  Hay dos formas de actualizar un recurso: actualizar sólo los campos requeridos, o bien mandar a actualizar el objeto completo, ambas formas son válidas cuando hablamos de actualización, y dependerá del contexto.
- Método DELETE: Como bien lo indica el nombre, este método lo utilizamos cuando queremos eliminar algún recurso. Aquí no es necesario enviar nada desde el body, sin embargo, sí es importante indicar en el req.params el identificador para 
  que el servidor reconozca qué recurso debe eliminar.

      
- Objeto request: Objeto usado dentro de los servicios de express para poder realizar consultas más complejas.
  The req object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as req (and 
  the HTTP response is res) but its actual name is determined by the parameters to the callback function in which you’re working.  
  
  > req.query: Como su nombre lo indica, query refiere a las múltiples consultas que se pueden hacer a un determinado endpoint, basta conque en la url coloquemos el símbolo ? , entonces express reconocerá que hay que meter información al 
    objeto req.query para poder utilizarlo en el endpoint. Cuando buscamos algo en nuestro navegador, llamamos a un endpoint haciendo un determinado query.
    
    Conforme incrementa el dinamismo en las urls, es importante configurar el servidor para que reciba datos complejos desde la url, por ello hay que utilizar la línea:
                   app.use(express.urlencoded({ extended: true }));
    La línea anterior permitirá que el servidor pueda interpretar mejor los datos complejos que viajen desde la url, y mapearlos correctamente en el req.query.
    Es decir, cuando hagamos una peticion POST, cuando lleguen, que podamos recivir esos datos. Sino, llegara un objeto vacio. 
    
    Tambien tenemos la siguiente linea que dice que, cuando nosotros hagamos peticiones por POST, lleguen. O de lo cotrario, nos llegarian como undefined.
                   app.use(express.json());
  
  > req.params: Se utiliza cuando necesitamos obtener elementos dinámicos desde la ruta que está llamando el cliente. para poder definir un “parámetro” dentro de la ruta a trabajar, basta con colocar el símbolo de dos puntos (:) antes del 
    parámetro, de esta manera, express reconoce que queremos que ese elemento sea dinámico.
    
  > ¿Qué diferencia hay con params? 
    La principal diferencia que hay entre req.params y req.query, es que en req.query puedo meter la cantidad de consultas que yo así desee, ya que las queries no vienen inmersas en la ruta, sino que son un elemento aparte.
    Así, si desconozco el número de cosas que se van a consultar en mi ruta, la mejor opción es utilizar queries, mientras que, si sólo necesito un número específico y reducido de parámetros, habría que optar por params
    Al final, no hay una mejor que otra, sirven para casos diferentes e incluso podemos utilizar ambas en la misma consulta. 
    
  > req.body:  
        
- Router en Express: Un router en express nos permitirá separar los endpoints “comunes” en entidades separadas que fungirán como “mini aplicaciones”, las cuales tomarán peticiones que concuerden con dicho endpoint y así redireccionarse a 
  esta mini aplicación. De esta manera, nuestro código resultará más organizado, y las diferentes entidades tendrán aislado el comportamiento interno, como configuraciones, middlewares, etc.
  
  > ¿Cómo aplicar un router? Primero recordemos la estructura de nuestro proyecto, hasta el momento, sabemos que la estructura básica de nuestro proyecto consiste en la distribución como lo indica la imagen: una carpeta donde vive el 
    proyecto, dentro una carpeta src donde vivirá nuestro código, y nuestro servidor dentro.
    Despues, agregaremos una carpeta “routes” donde vivirán nuestros diferentes routers (Nota que app.js se queda fuera de routes, pero sigue dentro de src).

- ¿Cómo convertir una carpeta en un recurso estático? 
  Para poder utilizar los recursos de una carpeta de manera estática, basta conque en el servidor especifiquemos como “express.static” dicha carpeta con la siguiente sintaxis: app.use(express.static('public')) Indicamos que, todo lo que viva 
  en la carpeta public, podrá ser accedido directamente desde la carpeta public. A continuación podemos cargar los archivos que queramos en el directorio public:
  http://localhost:3000/hello.html
  http://localhost:3000/images/kitten.jpg
  Nota: Express busca los archivos relativos al directorio estático, por lo que el nombre del directorio estático no forma parte del URL.
  
  > Prefijo virtual: Para crear un prefijo virtual (donde el path de acceso no existe realmente en el sistema de archivos) para los archivos servidos por express.static, debemos especificar un path de acceso de montaje para el directorio 
    estático:  app.use('/static', express.static('public'));
    Así podemos cargar los archivos que hay en el directorio public desde el prefijo /static.
    http://localhost:3000/static/hello.html
    http://localhost:3000/static/images/kitten.jpg
    
  > Path absoluto: El path que se proporciona a la función express.static es relativo al directorio desde donde inicia el proceso node. Por eso si ejecutamos la aplicación Express desde cualquier otro directorio, es más seguro utilizar el 
    path absoluto del directorio al que desea dar servicio:   app.use('/static', express.static(__dirname + '/public'))
    
- middleware: Seguramente te has dado cuenta de que que hemos utilizado mucho la sintaxis app.use. ¿Qué pasa de manera interna en este punto?
  Cada vez que utilizamos un app.use estamos utilizando un middleware. Éstas son operaciones que se ejecutan de manera intermedia entre la petición del cliente, y el servicio de nuestro servidor.
  Como lo indica el nombre: “middleware” hace referencia a un intermediario, siempre se ejecuta antes de llegar al endpoint que corresponde. los middlewares se ejecutan EN ORDEN, eso quiere decir que, si algún middleware depende de que se 
  haya realizado otra operación ejecutada por un middleware previo, los coloquemos en cascada según prioridad. Podemos utilizar un middleware para:
    ✓ Dar información sobre las consultas que se están haciendo (logs) 
    ✓ Autorizar o rechazar usuarios antes de que lleguen al endpoint (seguridad) 
    ✓ Agregar o alterar información al método req antes de que llegue al endpoint (formato) 
    ✓ Redireccionar según sea necesario (router) 
    ✓ En ciertos casos, finalizar la petición sin que llegue al endpoint (seguridad)
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   GitHub
  
  - GIT: Sistema de control de versiones gratuito y de código abierto, diseñado para manejar desde pequeños a grandes proyectos de manera rápida y eficaz. Se entiende como control de versiones a 
    todas las herramientas que nos permiten hacer modificaciones en nuestro proyecto. Este sistema registra los cambios realizados sobre un archivo o conjunto de archivos a lo largo del tiempo.
    Con GIT, podemos ir a versiones anteriores, muy útil para errores, y para la organización.
    Con GIT, podemos ir a versiones anteriores, muy útil para errores, y para la organización.
    
    > Los 3 estados de GIT
      1. estado (el que trabajamos) “preparamos las cajas”. 
      2. estado (archivos listos) “agregamos las cajas listas”. 
      3. estado (registro de todos los archivos) “lote listo”.
      
    > Configurando GIT por primera vez
      ~ Tu identidad: Lo primero que deberías hacer cuando instalas Git es establecer tu nombre de usuario y dirección de correo electrónico. Esto es importante porque las confirmaciones de
         cambios (commits) en Git usan esta información, y es introducida de manera inmutable en los commits que envías.               john@MyShopSolutions: ~$ git --version                    
      ~ Elige un nombre de usuario que recuerdes fácil, y el email que en la próxima clase usarás en Github    
      ~ Establece el nombre con el comando: git config --global user.name "Nombre Apellido".       
      ~ Establece el correo a usar con el comando. git config --global user.email johndoe@example.com
            
    > Comprobando tu configuración  
      ~ Vamos a comprobar si guardamos bien el usuario usando el comando: git config --list
      ~ Puedes también comprobar qué valor tiene la clave nombre en Git ejecutando: git config user.name
             
    > Comandos básicos
       ✓ /?: si quieres saber más de un comando, añade /? para ver la ayuda relacionada. Te será muy útil para ver las muchas opciones de cada comando.
       ✓ HELP: te mostrará una lista de comandos disponibles.
       ✓ DIR: es el comando más conocido de DOS y sirve para ver elcontenido de una carpeta (en MAC-OS usar LS).
       ✓ CD: sirve para entrar en una carpeta o salir de ella (CD…).
       ✓ CLEAR: limpia la consola.     
       ✓ MKDIR: con este comando crearás una carpeta nueva. Con RMDIR podrás eliminarla.
       ✓ MOVE y COPY: son los comandos para mover y copiar archivos respectivamente. Deberás indicar el nombre del archivo con su ruta (si está en otra carpeta en la que te encuentras) y la
           ruta de destino.
       ✓ RENAME: sirve para renombrar un archivo o carpeta. Hay que indicar el nombre original y el definitivo.
       ✓ DEL: es el comando para eliminar un archivo. Recuerda que no irá a la Papelera, así que piensa muy bien antes de borrar algo. Y para eliminar carpeta usa el comando RD (en MAC-OS usar
           RM para archivos / para eliminar carpetas RM -RF).
       ✓ EXIT: cierra la ventana de la línea de comandos o símbolo del sistema.
       ✓ COPY CON: crear archivos (en MAC-OS usar TOUCH).
          
    > Comandos
      ✓ git help config    /   git config --help     /     git-config   obtener ayuda
      ✓ git init: indicarle que en ese directorio, donde ejecutamos este comando, será usado con GIT. 
      ✓ git add .: agregar todos los archivos creados, modificados, eliminados al estado 2 (stage)
      ✓ git commit -m “Mensaje”: mensaje obligatorio para indicar que hemos cambiado por ejemplo, al estado 3.
      ✓ Git log --online: para conocer loscódigos de los commits realizados.
      ✓ Git checkout rama: para cambiar de rama o ir a un commit específico (debemos conocer su código anteriormente)
      ✓ git merge rama: debemos estar en MASTER para fusionar.
      ✓ git branch rama: creación de una rama (si queremos eliminar una rama ponemos git branch -D nombre-rama)
      ✓ git branch -D rama: borrar ramas
      ✓ git remote -v: Ver url del repositorio
      ✓ git reflog: Ver historial
      
      ✓ git init initializes your local directory as a new git repository. You must run this before you can commit any of your work.
      ✓ git status shows the current status of your repo. It will show you if you have any work that is unstaged, what branch you are on, how many commits you are ahead of the master remote on github, and other useful things.
      ✓ git diff shows you the changes in your unstaged code.
      ✓ git remote -v shows you all the remotes for your repo. The v stands for verbose, which shows you the URL of the repository on github, if any, that your local repository is pointing to rather than just the name of the remote repo.
      ✓ git add . takes all unstaged work and stages it, making it ready to be committed. You can also specify a particular file to stage with git add file-path/name-of-file
      ✓ git commit -m "write commit message here" commits all staged work. It’s important to write a brief, clear commit message so you know what each commit is for. “Final commit” is not the commit message you’re looking for exactly 100% of 
           the time.
      ✓ git pull once you've committed all your local work and running git status shows that you have nothing to commit, you pull down any changes from your remote. By default, this will pull from the origin remote’s master branch. To be 
           specific about which remote and branch to pull from, you can use: git pull name-of-remote name-of-branch
      ✓ git push pushes your local changes up to your remote. By default, this will push to the origin remote’s master branch. Like pull, you can push to a specific remote and branch with: git push name-of-remote name-of-branch. This is 
           useful if you are using branches and pull requests. If you get an error message, it’s probably because you haven’t pushed your local branch up to github yet. Try git push -u name-of-remote name-of-branch.
      ✓ git branch shows you all your local branches and indicates which branch you are currently on.
      ✓ git checkout -b name-of-new-branch makes a new branch and switches to that branch.
      ✓ git merge name-of-branch will merge the specified branch into the branch you are currently on.
      ✓ git branch -d name-of-branch-to-delete deletes the specified branch
      ✓ git log will show you the full list of commits and authors for your repo
      ✓ history will show you your past git commands
      ✓ git stash stashes any unstaged changes in your repository. They will not be present in your codebase, but they are not deleted.
      ✓ git stash pop gives you back the last staged changes you stashed
      ✓ git blame file-path/name-of-file shows you line-by-line who wrote the code in the specified file. Useful when you have a question about how something works and want to figure out who to ask, and also great source of shame when you 
          realize you wrote the chunk of code you’ve been swearing at for the last hour.
            
      + Configurar global main como nombre de rama principal:
        git config --global init.defaultBranch main

      + error: remote origin already exists:
        git remote set-url origin [url]
 
      + Ver url del repositorio:
        git remote -v

      + Eliminar commit especifico:
        git revert [commit]
        (cerrar ventana del editor)(se crea nuevo commit)

      + Clonar repositorio:
        git clone [url]

      + Ver historial:
        git reflog
 
      + Deshace todos los commits después de [commit], preservando los cambios localmente:
        git reset [commit]
 
      + Desecha todo el historial y regresa al commit especificado:
        git reset --hard [commit]
        
        
     > Para iniciar sesion cuando se requiera, debemos:
       1. Credenciales de Windows 
       
       2. Cambiar el username y email de Git
          git config --global user.name "new name"
          git config --global user.email newcorreo@example.com 
       
       3. Cambiar el usuario de Credenciales
          git config credential.username "new name"
          
       4. En caso de que la terminal diga que no reconozca, debemos escribir lo siguiente para que podamos iniciar sesion desde el navegador y que aparezca la ventanilla
          git push --set-upstream origin main        
       
       5. Para validar la configuración actual
          git config --global -e    
          
     > Si quiero agregar cambios a Github desde VS code, necesito:
       1. git add .
       2. git commit -m "escribir cualquier nombre al cambio"
       3. git push      o tambien     git push -u origin main

  
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Glosario
                                                                                                                   
- Parse: Parsing is the process of analyzing text made of a sequence of tokens to determine its grammatical structure with respect to a given (more or less) formal grammar. The parser then builds a data structure based on the tokens. This 
  data structure can then be used by a compiler, interpreter or translator to create an executable program or library.
  To parse, in computer science, is where a string of commands – usually a program – is separated into more easily processed components, which are analyzed for correct syntax and then attached to tags that define each component. The 
  computer can then process each program chunk and transform it into machine language. To parse is to break up a sentence or group of words into separate components, including the definition of each part’s function or form. The technical 
  definition implies the same concept.
  
- callback:   
  
- Renderizar: El renderizado es un proceso utilizado en desarrollo web para convertir el código de un website en una página con la que las usuarias y usuarios puedan interactuar. Como tal, el término hace referencia a la conversión de los
  códigos HTML, CSS y JS que son los encargados de la interfaz y contenido de la página. El proceso para renderizar una web se realiza con un motor de renderizado o software que, por lo general, ejecutan los navegadores. A estos motores de 
  renderizado también se los conoce comúnmente como motores del navegador. El rendering se desarrolla de la siguiente manera:
    > Construcción de un DOM y un CSSOM partiendo de un código sin formato
       + Mientras se carga el sitio, el servidor web envía una carpeta o archivo que contiene los códigos HTML, CSS y JS al navegador de la usuaria o usuario.
       + Seguidamente, el navegador convierte los datos (bytes) en caracteres (código HTML).
       + A continuación, se descompone los caracteres en tokens (en el tokenizardor) y luego se verifican en nodos (parser).
       + A partir de aquí el motor del navegador enlaza los nodos en una estructura de tipo árbol, conocida como DOM, del inglés: Document Object Model o Modelo de Objeto de Documento, que es la representación del Javascript del HTML.
       + Simultáneamente, el navegador convierte el código CSS en un CSSOM (Modelo de objeto CSS) mediante un proceso similar.
    > Uso del árbol de renderizado para crear una página web final
       + El motor del navegador combina los archivos DOM y CSSOM para crear una estructura similar a un árbol que se llama “árbol de renderizado” y que incluye la información de contenido y estilo que necesitan los navegadores para llenar la
         página que las o los internautas van a ver. También estima el diseño para cada elemento visible del sitio y les da color en la pantalla para lograr el resultado final que él y la usuaria verán.
       + El siguiente paso es la operación del diseño final. Mediante el árbol de renderizado, el motor del navegador calcula la posición de cada elemento visible en la página final.
       + Por último, el motor del navegador añade o colorea los elementos en la pantalla para que la persona pueda visualizar el resultado.
      Una vez completados los pasos en ambas secuencias, se puede decir que la página está renderizada.
    > Renderizado dinámico: Javascript es una elección frecuente para renderizar una página, porque permite crear una experiencia de usabilidad intuitiva. Sin embargo, muchos rastreadores suelen presentar problemas al procesar Javascript. 
      En consecuencia, los sitios que utilizan Javascript para almacenar la mayor parte de su contenido y navegabilidad corren el riesgo de ser invisibles para los rastreadores. No obstante, el renderizado dinámico soluciona este tipo de 
      problemas al renderizar una página para las y los internautas, como se describe en los párrafos anteriores, mientras que también renderiza el HTML estático para que los bots puedan rastrearla e indexarla.
                                                                                                                   
- DOM documents (Document Object Model): El Modelo de Objetos del Documento (DOM) es una estructura de objetos generada por el navegador, la cual representa la página HTML actual. Con JavaScript la empleamos para acceder y  modificar de 
  forma dinámica elementos de la  interfaz. 
  La estructura de un documento HTML son las etiquetas. En el Modelo de Objetos del Documento (DOM), cada etiqueta HTML es un objeto, al que podemos llamar nodo. Las etiquetas anidadas son llamadas “nodos 
  hijos” de la etiqueta “nodo padre” que las contiene. Todos estos objetos son accesibles empleando JavaScript mediante el objeto global document.   
  Es una interfaz de programación que nos permite crear, cambiar, o remover elementos del documento. También podemos agregar eventos a esos elementos para hacer más dinámica nuestra página.
  El DOM visualiza el documento de HTML como un árbol de tres nodos. Un nodo representa un documento de HTML.            
  
  The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects; that way,
  programming languages can interact with the page. A web page is a document that can be either displayed in the browser window or as the HTML source. In both cases, it is the same document but the Document Object Model (DOM) representation 
  allows it to be manipulated. As an object-oriented representation of the web page, it can be modified with a scripting language such as JavaScript. 
  It connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory. Usually it refers to JavaScript, even though modeling 
  HTML, SVG, or XML documents as objects are not part of the core JavaScript language. The DOM represents a document with a logical tree. Each branch of the tree ends in a node, and each node contains objects. DOM methods allow programmatic 
  access to the tree. With them, you can change the document's structure, style, or content. Nodes can also have event handlers attached to them. Once an event is triggered, the event handlers get executed.                                                                                         

-Virtual DOM:               
                                                                                                                   

- Buffer: 

- Exportacion (export): Now, importing is an operation that requires the permission of the module. Importing is possible only if the module or named property to be imported has been exported in its declaration. In React we use the keyword 
  export to export a particular module or a named parameter or a combination. Let us now see the different ways we can use the import operation in React.

  > Exportación por defecto: Para exportar un componente por defecto, usamos la palabra reservada default. La gran desventaja que tiene la exportación por defecto es que a la hora de importarlo puedes usar el nombre que quieras. Y esto trae 
    problemas, ya que puedes no usar siempre el mismo en el proyecto o usar un nombre que no sea correcto con lo que importas.
  > Exportación nombrada: Los exports nombrados nos obligan a usar el mismo nombre en todos los archivos y, por tanto, nos aseguramos de que siempre estamos usando el nombre correcto.

- pluggins: 

- polyfills: Un polyfill es un fragmento de código (generalmente JavaScript en la Web) que se utiliza para proporcionar una funcionalidad moderna en navegadores antiguos que no lo admiten de forma nativa. Por ejemplo, se podría usar un 
  polyfill para imitar la funcionalidad de un elemento HTML Canvas en Microsoft Internet Explorer 7 usando un complemento de Silverlight, o un soporte mímico para las unidades rem CSS, o text-shadow, o lo que tu quieras.
   
- 
   
    